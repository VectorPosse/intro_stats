[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Statistics: an integrated textbook and workbook using R",
    "section": "",
    "text": "Introduction\nWelcome to statistics!",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction to Statistics: an integrated textbook and workbook using R",
    "section": "Getting started",
    "text": "Getting started\nThis book assumes you are using the R language and the RStudio software. If you are using this book for a class, your teacher will let you know if you need to download R and RStudio on your own device or if you will be using R and RStudio through a web browser. If you are using a web browser, you might be using R installed on a central server, or you might be using it through a cloud service (like Posit Cloud, for example). If you are using this book for self-study, you can choose how you want to interact with R and RStudio. (R and RStudio can be downloaded and installed on your machine for free. Cloud services often have a selection of free and paid tiers.)\nOnce you get RStudio or Posit up and running, you are all set to go to Chapter 1 and get started.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#history-and-goals",
    "href": "index.html#history-and-goals",
    "title": "Introduction to Statistics: an integrated textbook and workbook using R",
    "section": "History and goals",
    "text": "History and goals\nIn 2015, a group of interdisciplinary faculty at Westminster University (then called Westminster College) in Salt Lake City, Utah, started a process that led to the creation of a new Data Science program. Preparatory to creating a more rigorous introductory statistics course using the statistical software R, I wrote a series of 22 modules that filled a gap in the R training literature. Most R training at the time was focused either on learning to program using R as a computer language, or using R to do sophisticated statistical analysis. We needed our students to use R as a tool for elementary statistical methods and we needed the learning curve to be as gentle as possible. I decided early on that to make the modules more useful, they needed to be structured more like an interactive textbook rather than just a series of lab exercises, and so I spent the summer of 2016 writing a free, open-source, self-contained, and nearly fully-featured introductory statistics textbook. The first sections of the newly-created DATA 220 were offered in Fall, 2016, using the materials I created.\nSince then, I have been revising and updating the modules a little every semester. At some point, however, it became clear that some big changes needed to happen:\n\nThe modules were more or less aligned with the OpenIntro book Introduction to Statistics with Randomization and Simulation (ISRS) by David Diez, Christopher Barr, and Mine Çetinkaya-Rundel. That book has now been supplanted by Introduction to Modern Statistics (IMS) by Mine Çetinkaya-Rundel and Johanna Hardin, also published through the OpenIntro project.\nThe initial materials were written mostly using a mix of base R tools, some tidyverse tools, and the amazing resources of the mosaic package. I wanted to convert everything to be more aligned with tidyverse packages now that they are mature, well-supported, and becoming a de facto standard for doing data analysis in R.\nThe initial choice of data sets that served as examples and exercises for students was guided by convenience. As I had only a short amount of time to write an entire textbook from scratch, I tended to grab the first data sets I could find that met the conditions needed for the statistical principles I was trying to illustrate. It has become clear in the last few years that the material will be more engaging with more interesting data sets. Ideally, we should use at least some data sets that speak to issues of social justice.\nMaking statistics more inclusive requires us to confront some ugly chapters in the development of the subject. Statistical principles are often named after people. (These are supposedly the people who “discovered” the principle, but keep in mind Stigler’s Law of Eponymy which states that no scientific discovery is truly named after its original discoverer. In a neat bit of self-referential irony, Stephen Stigler was not the first person to make this observation.) The beliefs of some of these people were problematic. For example, Francis Galton (famous for the concept of “regression to the mean”), Karl Pearson (of the Pearson correlation coefficient), and Ronald Fisher (famous for many things, including the P-value) were all deeply involved in the eugenics movement of the late 19th and early 20th century. The previous modules almost never referenced this important historical background and context. Additionally, it’s important to discuss ethics, whether that be issues of data provenance, data manipulation, choice of analytic techniques, framing conclusions, and many other topics.\n\nThe efforts of my revisions are here online. I’ve tried to address all the concerns mentioned above:\n\nThe chapter are arranged to align somewhat with IMS. There isn’t quite a one-to-one correspondence, but teachers who want to use the chapters of my book to supplement instruction from IMS, or vice versa, should be able to do so pretty easily. In the Appendix, I’ve included a concordance that shows how the books’ chapters match up, along with some notes that explain when one book does more or less than the other.\nThe book is now completely aligned with the tidyverse and other packages that are designed to integrate into the tidyverse. All plotting is done with ggplot2 and all data manipulation is done with dplyr, tidyr, and forcats. Tables are created using tabyl from the janitor package. Inference is taught using the cool tools in the infer package.\nI have made an effort to find more interesting data sets. It’s tremendously difficult to find data that is both fascinating on its merits and also meets the pedagogical requirements of an introductory statistics course. I would like to use even more data that addresses social justice issues. There’s some in the book now, and I plan to incorporate even more in the future as I come across data sets that are suitable.\nWhen statistical tools are introduced, I have tried to give a little historical context about their development if I can. I’ve also tried to frame every step of the inferential process as a decision-making process that requires not only analytical expertise, but also solid ethical grounding. Again, there’s a lot more I could do here, and my goal is to continue to develop more such discussion as I can in future revisions.\n\nNow, instead of a bunch of separate module files, all the material is gathered in one place as chapters of a book. In each chapter (starting with Chapter 2), students can download the chapter as a Quarto document, open it in RStudio, and work through the material.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#philosophy-and-pedagogy",
    "href": "index.html#philosophy-and-pedagogy",
    "title": "Introduction to Statistics: an integrated textbook and workbook using R",
    "section": "Philosophy and pedagogy",
    "text": "Philosophy and pedagogy\nTo understand my statistics teaching philosophy, it’s worth telling you a little about my background in statistics.\nAt the risk of undermining my own credibility, I’d like to tell you about the first statistics class I took. In the mid-2000s, I was working on my Ph.D. at the University of California, San Diego, studying geometric topology. To make a little extra money and get some teaching experience under my belt, I started teaching night and summer classes at Miramar College, a local community college in the San Diego Community College District. I had been there for several semesters, mostly teaching pre-calculus, calculus, and other lower-division math classes. One day, I got a call from my department chair with my assignment for the upcoming semester. I was scheduled to teach intro stats. I was about to respond, “Oh, I’ve never taken a stats class before.” But remembering this was the way I earned money to be able to live in expensive San Diego County, I said, “Sounds great. By the way, do you happen to have an extra copy of the textbook we’ll be using?”\nYes, the first statistics class I took was the one I taught. Not ideal, I know.\nI was lucky to start teaching with Intro Stats by De Veaux, Velleman, and Bock, a book that was incredibly well-written and included a lot of resources for teachers like me. (I learned quickly that I wasn’t the only math professor in the world who got thrown into teaching statistics classes with little-to-no training.) I got my full-time appointment at Westminster in 2008 and continued to teach intro stats classes for many years to follow. As I mentioned earlier, we started the Data Science program at Westminster in 2016 and moved everything from our earlier hodgepodge of calculators, spreadsheets, and SPSS, over to R.\nEventually, I got interested in Bayesian statistics and read everything I could get my hands on. I became convinced that Bayesian statistics is the right way to do statistical analysis. I started teaching special topics courses in Bayesian Data Analysis and working with students on research projects that involved Bayesian methods. If it were up to me, every introductory statistics class in the world would be taught using Bayesian methods. I know that sounds like a strong statement. (And I put it in boldface, so it looks even stronger.) But I truly believe that in an alternate universe where Fisher and his disciples didn’t “win” the stats wars of the 20th century (and perhaps one in which computing power got a little more advanced a little earlier in the development of statistics), we would all be Bayesians. Bayesian thinking is far more intuitive and more closely aligned with our intuitions about probabilities and uncertainty.\nUnfortunately, our current universe timeline didn’t play out that way. So we are left with frequentism. It’s not that I necessarily object to frequentist tools. All tools are just tools, after all. However, the standard form of frequentist inference, with its null hypothesis significance testing, P-values, and confidence intervals, can be confusing. It’s bad enough that professional researchers struggle with them. We teach undergraduate students in introductory classes.\nOkay, so we are stuck not in the world we want but in the world we’ve got. At my institution and most others, intro stats is a service course that trains far more people who are outside the fields of mathematics and statistics. In that world, students will go on to careers where they interact with research that reports P-values and confidence intervals.\nSo what’s the best we can do for our students, given that limitation? We need to be laser-focused on teaching the frequentist logic of inference the best we can. I want student to see P-values in papers and know how to interpret those P-values correctly. I want students to understand what a confidence interval tells them—and even more importantly, what it does not tell them. I want students to respect the severe limitations inherent in tests of significance. If we’re going to train frequentists, the least we can do is help them become good frequentists.\nOne source of inspiration for good statistical pedagogy comes from the Guidelines for Assessment and Instruction in Statistics Education (GAISE), a set of recommendations made by experienced stats educators and endorsed by the American Statistical Association. Their college guidelines are as follows:\n\nTeach statistical thinking.\n\nTeach statistics as an investigative process of problem-solving and decision-making.\nGive students experience with multivariable thinking.\n\nFocus on conceptual understanding.\nIntegrate real data with a context and purpose.\nFoster active learning.\nUse technology to explore concepts and analyze data.\nUse assessments to improve and evaluate student learning.\n\nIn every element of this book, I’ve tried to follow these guidelines:\n\nThe first part of the book is an extensive guide for exploratory data analysis. The rest of the book is about inference in the context of specific research questions that are answered using statistical tools. While multivariable thinking is a little harder to do in an intro stats class, I take the opportunity whenever possible to use graphs to explore more variables than we can handle with intro stats inferential techniques. I point out the the simple analyses taught in this class are only the first step in more comprehensive analyses that incorporate more information and control for confounders. I emphasize that students can continue their statistical growth by enrolling in more advanced stats classes.\nI often tell students that if they forget everything else from their stats class, the one think I want them to be able to do is interpret a P-value correctly. It’s not intuitive, so it takes an entire semester to set up the idea of a sampling distribution and explain over and over again how the P-value relates to it. In this book, I try to reinforce the logic of inference until the students know it almost instinctively. A huge pedagogical advantage is derived by using randomization and simulation to keep students from getting lost in the clouds of theoretical probability distributions. But they also need to know about the latter too. Every hypothesis test is presented both ways, a task made easy when using the infer package.\nThis is the thing I struggle with the most. Finding good data is hard. Over the years, I’ve found a few data sets I really like, but my goal is to continue to revise the book to incorporate more interesting data, especially data that serves to highlight issues of social justice.\nBack when I wrote the first set of modules that eventually became this book, the goal was to create assignments that merged content with activities so that students would be engaged in active learning. When these chapters are used in the classroom, students can collaborate with each other and with their professor. They learn by doing.\nUnlike most books out there, this book does not try to be agnostic about technology. This book is about doing statistics in R.\nThis one I’ll leave in the capable hands of the professors who use these materials. The chapter assignments should be completed and submitted, and that is one form of assessment. But I also believe in augmenting this material with other forms of assessment that may include supplemental assignments, open-ended data exploration, quizzes and tests, projects, etc.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#course-structure",
    "href": "index.html#course-structure",
    "title": "Introduction to Statistics: an integrated textbook and workbook using R",
    "section": "Course structure",
    "text": "Course structure\nAs explained above, this book is meant to be a workbook that students complete as they’re reading.\nAt Westminster University, we use Posit Cloud. The cloud solution has a free tier, but in our experience, it’s not quite enough compute hours for this course. Various affordable paid options are available, like having students pay a monthly fee for access, or having the institution pay for the accounts.\nIn the past, we’ve also hosted Posit Workbench on a local server that is connected to our single sign-on (SSO) systems so that students can access RStudio through a browser using their campus online usernames and passwords. If you have the ability to convince your IT folks to support such a server, it’s very helpful. Rather than spending the first day of class troubleshooting while students try to install software on their machines, you can just have them log in and get started right away. Campus admins install packages and tweak settings to make sure all students have a standardized interface and consistent experience.\nIf you don’t have that luxury, or if you don’t want to pay for the cloud accounts, you will need to have students download and install both R and RStudio. The installation processes for both pieces of software are very easy and straightforward for the majority of students. If your students are running R on their own machines or if they’re using Posit Cloud, they will need to use install.packages at the beginning of some of the chapters for any new packages that are introduced. (They are mentioned at the beginning of each chapter with instructions for installing them.)\nChapter 1 is fully online and introduces R and RStudio very gently using only commands at the Console. They will create a project called intro_stats in RStudio that should be used all semester to organize their work. There is a reminder at the beginning of all subsequent chapter to make sure they are in that project before starting to do any work. (Generally, there is no reason they will exit the project, but some students get curious and click on stuff.)\nIn Chapter 2, students are taught to click a link to download a Quarto document (.qmd). I have found that students struggle initially to get this file to the right place. If students are using RStudio online, they will need to use the “Upload” button in the Files tab in RStudio to get the file from their Downloads folder (or wherever they tell their machine to put downloaded files from the internet) into RStudio. If students are using R on their own machines, they will need to move the file from their Downloads folder into their project directory. There are some students who have never had to move files around on their computers, so this is a task that might require some guidance from classmates, TAs, or the professor. The location of the project directory and the downloaded files can vary from one machine to the next. They will have to use something like File Explorer for Windows or the Finder for MacOS, so there isn’t a single set of instructions that will get all students’ files successfully in the right place. Once the file is in the correct location, students can just click on it to open it in RStudio and start reading. Chapter 2 is all about using Quarto documents: markdown syntax, R code chunks, and inline code.\nBy Chapter 3, a rhythm is established that students will start to get used to:\n\nOpen the book online and open RStudio.\nInstall any packages in RStudio that are new to that chapter.\nCheck to make sure they’re are in the intro_stats project.\nClick the link online to download the Quarto document.\nMove the Quarto document from the Downloads folder to the project directory.\nOpen up the Quarto document.\nRestart R and Run All Chunks.\nStart reading and working.\n\nWhen students finish each assignment, they will Restart R and Run All Chunks one last time and then “Render” the Quarto document, which will create HTML output that can then be submitted. (Hopefully, they will also take the opportunity to spell check and proofread thoroughly before submission. It’s important to proofread the HTML document not just for the writing, but also to make sure that the code output and formatting all looks correct.)\nChapters 3 and 4 focus on exploratory data analysis for categorical and numerical data, respectively.\nChapter 5 is a primer on data manipulation using dplyr.\nChapters 6 and 7 cover correlation and regression. This “early regression” approach mirrors the IMS text. (IMS eventually circles back to hypothesis testing for regression, but this book does not. That’s a topic that is covered extensively in most second-semester stats classes.)\nChapters 8–11 are crucial for building the logical foundations for inference. The idea of a sampling distribution under the assumption of a null hypothesis is built up slowly and intuitively through randomization and simulation. By the end of Chapter 11, students will be fully introduced to the structure of a hypothesis test, and hopefully will have experienced the first sparks of intuition about why it “works.” All inference in this book is conducted using a “rubric” approach—basically, the steps are broken down into bite-sized pieces and students are expected to work through each step of the rubric every time they run a test. (The rubric steps are shown in the Appendix.)\nChapter 12 introduces a few more steps to the rubric for confidence intervals. As we are still using randomization to motivate inference, confidence intervals are calculated using the bootstrap approach for now.\nOnce students have developed a conceptual intuition for sampling distributions using simulation, we can introduce probability models. Chapter 13 introduces normal models and Chapter 14 explains why they are often appropriate for modeling sampling distributions.\nThe final chapters of the book (Chapters 15–22) are simply applications of inference in specific data settings: inference for one (Ch. 15) and two (Ch. 16) proportions, Chi-square tests for goodness-of-fit (Ch. 17) and independence (Ch. 18), inference for one mean (Ch. 19), paired data (Ch. 20), two independent means (Ch. 21), and finally ANOVA (Ch. 22). Along the way, students learn about the chi-square, Student t, and F distributions. Although the last part of the book follows a fairly traditional parametric approach, every chapter still includes randomization and simulation to some degree so that students don’t lose track of the intuition behind sampling distributions under the assumption of a null hypothesis.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#onward-and-upward",
    "href": "index.html#onward-and-upward",
    "title": "Introduction to Statistics: an integrated textbook and workbook using R",
    "section": "Onward and upward",
    "text": "Onward and upward\nI hope you enjoy the textbook. You can provide feedback two ways:\n\nThe preferred method is to file an issue on the Github page: https://github.com/VectorPosse/intro_stats/issues\nAlternatively, send me an email: sraleigh@westminsteru.edu",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-intro_to_r.html",
    "href": "01-intro_to_r.html",
    "title": "1  Introduction to R",
    "section": "",
    "text": "1.1 Introduction\nWelcome to R! This chapter will walk you through everything you need to know to get started using R.\nAs you go through this chapter (and all future chapters), please read slowly and carefully, and pay attention to detail. Many steps depend on the correct execution of all previous steps, so reading quickly and casually might come back to bite you later.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#what-is-r",
    "href": "01-intro_to_r.html#what-is-r",
    "title": "1  Introduction to R",
    "section": "1.2 What is R?",
    "text": "1.2 What is R?\nR is a programming language specifically designed for doing statistics. Don’t be intimidated by the word “programming” though. The goal of this course is not to make you a computer programmer. To use R to do statistics, you don’t need know anything about programming at all. Every chapter throughout the whole course will give you examples of the commands you need to use. All you have to do is use those example commands as templates and make the necessary changes to adapt them to the data you’re trying to analyze.\nThe greatest thing about R is that it is free and open source. This means that you can download it and use it for free, and also that you can inspect and modify the source code for all R functions. This kind of transparency does not exist in commercial software. The net result is a robust, secure, widely-used language with literally tens of thousands of contributions from R users all over the world.\nR has also become a standard tool for statistical analysis, from academia to industry to government. Although some commercial packages are still widely used, many practitioners are switching to R due to its cost (free!) and relative ease of use. After this course, you will be able to list some R experience on your résumé and your future employer will value this. It might even help get you a job!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#rstudio",
    "href": "01-intro_to_r.html#rstudio",
    "title": "1  Introduction to R",
    "section": "1.3 RStudio",
    "text": "1.3 RStudio\nRStudio is an “Integrated Development Environment,” or IDE for short. An IDE is a tool for working with a programming language that is fancier than just a simple text editor. Most IDEs give you shortcuts, menus, debugging facilities, syntax highlighting, and other things to make your life as easy as possible.\nOpen RStudio so we can explore some of the areas you’ll be using in the future. (How to do this will depend on whether you’ve installed RStudio on your personal computer or logged into a cloud server. If you are in a class, your teacher will explain how to do this. For local installations, you should just be able to open RStudio. For cloud applications, you may need to start a “New Session” or a “New Project”.)\nIt should look something like this:\n\n\n\nScreenshot of RStudio at startup\n\n\nOn the left side of your screen, you should see a big pane called the “Console”. There will be some startup text there, and below that, you should see a “command prompt”: the symbol “&gt;” followed by a blinking cursor. (If the cursor is not blinking, that means that the focus is in another pane. Click anywhere in the Console and the cursor should start blinking again.)\nA command prompt can be one of the more intimidating things about starting to use R. It’s just sitting there waiting for you to do something. Unlike other programs where you run commands from menus, R requires you to know what you need to type to make it work.\nWe’ll return to the Console in a moment.\nNext, look at the upper-right corner of the screen. There are at least three tabs in this pane starting with “Environment”, “History”, and “Connections”. The “Environment” (also called the “Global Environment”) keeps track of things you define while working with R. There’s nothing to see there yet because we haven’t defined anything! The “History” tab will likewise be empty; again, we haven’t done anything yet. We won’t use the “Connections” tab in this course. (Depending on the version of RStudio you are using and its configuration, you may see additional tabs, but we won’t need them for this course.)\nNow look at the lower-right corner of the screen. There are likely six tabs here: “Files”, “Plots”, “Packages”, “Help”, “Viewer”, and “Presentation”. The “Files” tab will eventually contain the files you upload or create. “Plots” will show you the result of commands that produce graphs and charts. “Packages” will be explained later. “Help” is precisely what it sounds like; this will be a very useful place for you to get to know. We will never use the “Viewer” or “Presentation” tabs, so don’t worry about them.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#important",
    "href": "01-intro_to_r.html#important",
    "title": "1  Introduction to R",
    "section": "1.4 IMPORTANT!!",
    "text": "1.4 IMPORTANT!!\nThere is a setting you need to change for RStudio to work properly for you as you move through assignments in the future. Find the Tools menu (at the top of the screen, between “Profile” and “Help”) and go to the bottom where it says “Global Options…”\nIn the Workspace section, where it says “Save workspace to .RData on exit”, you must change the drop-down menu from “Ask” to “Never”. The menu is highlighted in the image below:\n\n\n\nChange Ask to Never in this menu.\n\n\nBe sure to scroll down and click the OK button when you’re done.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#try-something",
    "href": "01-intro_to_r.html#try-something",
    "title": "1  Introduction to R",
    "section": "1.5 Try something!",
    "text": "1.5 Try something!\nSo let’s do something in R! Go back to the Console and at the command prompt (the “&gt;” symbol with the blinking cursor), type\n\n1+1\n\nand hit Enter.\nCongratulations! You just ran your first command in R. It’s all downhill from here. R really is nothing more than a glorified calculator.\nOkay, let’s do something slightly more sophisticated. It’s important to note that R is case-sensitive, which means that lowercase letters and uppercase letters are treated differently. Type the following, making sure you use a lowercase x and lowercase c, and hit Enter:\n\nx &lt;- c(1, 3, 4, 7, 9)\n\nYou have just created a “vector”. When we use the letter c and enclose a list of things in parentheses, we tell R to “combine” those elements. So, a vector is just a collection of data. The little arrow &lt;- says to take what’s on the right and assign it to the symbol on the left. The vector x is now saved in memory. As long as you don’t terminate your current R session, this vector is available to you.\nCheck out the “Environment” pane now. You should see the vector x that you just created, along with some information about it. Next to x, it says num, which means your vector has numerical data. Then it says [1:5] which indicates that there are five elements in the vector x.\nAt the command prompt in the Console, type\n\nx\n\nand hit Enter. Yup, x is there. R knows what it is. You may be wondering about the [1] that appears at the beginning of the line. To see what that means, try typing this (and hit Enter—at some point here I’m going to stop reminding you to hit Enter after everything you type):\n\ny &lt;- letters\n\nR is clever, so the alphabet is built in under the name letters.\nType\n\ny\n\nNow can you see what the [1] meant above? Assuming the letters spilled onto more than one line of the Console, you should see a number in brackets at the beginning of each line telling you the numerical position of the first entry in each new line.\nSince we’ve done a few things, check out the “Global Environment” in the upper-right corner. You should see the two objects we’ve defined thus far, x and y. Now click on the “History” tab. Here you have all the commands you have run so far. This can be handy if you need to go back and re-run an earlier command, or if you want to modify an earlier command and it’s easier to edit it slightly than type it all over again. To get an older command back into the Console, either double-click on it, or select it and click the “To Console” button at the top of the pane.\nWhen we want to re-use an old command, it has usually not been that long since we last used it. In this case, there is an even more handy trick. Click in the Console so that the cursor is blinking at the blank command prompt. Now hit the up arrow on your keyboard. Do it again. Now hit the down arrow once or twice. This is a great way to access the most recently used commands from your command history.\nLet’s do something with x. Type\n\nsum(x)\n\nI bet you figured out what just happened.\nNow try\n\nmean(x)\n\nWhat if we wanted to save the mean of those five numbers for use later? We can assign the result to another variable! Type the following and click on the Environment tab to observe the effect.\n\nm &lt;- mean(x)\n\nIt makes no difference what letter or combination of letters we use to name our variables. For example,\n\nmean_x &lt;- mean(x)\n\njust saves the mean to a differently named variable. In general, variable names can be any combination of characters that are letters, numbers, underscore symbols (_), and dots (.). (In this course, we will prefer underscores over dots.) You cannot use spaces or any other special characters in the names of variables.1 You should avoid variable names that are the same words as predefined R functions; for example, we should not type mean &lt;- mean(x).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#load-packages",
    "href": "01-intro_to_r.html#load-packages",
    "title": "1  Introduction to R",
    "section": "1.6 Load packages",
    "text": "1.6 Load packages\nPackages are collections of commands, functions, and sometimes data that people all over the world write and maintain. These packages extend the capabilities of R and add useful tools. For example, we would like to use the palmerpenguins package because it includes an interesting data set on penguins.\nType the following at the command prompt in the Console:2\n\ninstall.packages(\"palmerpenguins\")\n\nWe are doing this because you’ve never used the palmerpenguins package before. Once a package is installed, though, it never has to be installed again.\nAfter we’ve installed the package (the one-time process we completed above), we will need to load the package in every R session in which we want to use it. For example, the palmerpenguins package contains a data set called penguins. Let’s see what happens when we try to access this data set without loading the package that contains it. Typing this will produce an error:\n\npenguins\n\nThat error makes sense because R doesn’t know anything about a data set called penguins.\nBut since the palmerpenguins package has been installed, you can now type this at the command prompt:\n\nlibrary(palmerpenguins)\n\nIt didn’t look like anything happened. However, in the background, all the stuff in the palmerpenguins package became available to use.\nLet’s test that claim. Hit the up arrow twice and get back to where you see this at the Console (or you can manually re-type it, but that’s no fun!):\n\npenguins\n\nNow R knows about the penguins data, so the last command printed some of it to the Console.\nGo look at the “Packages” tab in the pane in the lower-right corner of the screen. Scroll down a little until you get to the “P”s. You should be able to find the palmerpenguins package. You’ll also notice a check mark by it, indicating that this package is loaded into your current R session.\nYou must use the library command in every new R session in which you want to use a package. If you terminate your R session, R forgets about the package. If you are ever in a situation where you are trying to use a command and you know you’re typing it correctly, but you’re still getting an error, check to see if the package containing that command has been loaded with library. (Many R commands are “base R” commands, meaning they come with R and no special package is required to access them. The set of letters you used above is one such example.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#getting-help",
    "href": "01-intro_to_r.html#getting-help",
    "title": "1  Introduction to R",
    "section": "1.7 Getting help",
    "text": "1.7 Getting help\nThere are three important ways to get help with R. The first is the obvious “Help” tab in the lower-right pane on your screen. Click on that tab now. In the search bar at the right, type penguins and hit Enter. Take a few minutes to read the help file.\nHelp files are only as good as their authors. Fortunately, most package developers are conscientious enough to write decent help files. But don’t be surprised if the help file doesn’t quite tell you what you want to know. And for highly technical R functions, sometimes the help files are downright inscrutable. Try looking at the help file for the grep function. Can you honestly say you have any idea what this command does or how you might use it? Over time, as you become more knowledgeable about how R works, these help files get less mysterious.\nThe second way of getting help is from the Console. Go to the Console and type\n\n?letters\n\nThe question mark tells R you need help with the R command letters. This will bring up the help file in the same Help pane you were looking at before.\nSometimes, you don’t know exactly what the name of the command is. For example, suppose we misremembered the name and thought it was letter instead of letters. Try typing this:\n\n?letter\n\nYou should have received an error because there is no command called letter. Try this instead:\n\n??letter\n\nand scroll down a bit in the Help pane. Two question marks tell R not to be too picky about the spelling. This will bring up a whole bunch of possibilities in the Help pane, representing R’s best guess as to what you might be searching for. (In this case, it’s not easy to find. You’d have to know that the help file for letters appeared on a help page called base::Constants.)\nThe third way to get help—and often the most useful way—is to use your best friend, the internet. You don’t want to just type “R” into a search engine. (That’s the downside of using a single letter of the alphabet for the name of a programming language.) However, if you type “R __________” where you fill in the blank with the topic of interest, search engines usually do a pretty good job sending you to relevant pages. Within the first few hits, in fact, you’ll often see an online copy of the same help file you see in R. Frequently, the next few hits lead to StackOverflow where very knowledgeable people post very helpful responses to common questions.\nUse a search engine to find out how to take the square root of a number in R. Test out your newly-discovered function on a few numbers in the Console to make sure it works.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#understanding-the-data",
    "href": "01-intro_to_r.html#understanding-the-data",
    "title": "1  Introduction to R",
    "section": "1.8 Understanding the data",
    "text": "1.8 Understanding the data\n\n\n\nAdélie Penguin, By Andrew Shiva / Wikipedia, CC BY-SA 4.0, Link\n\n\nLet’s go back to the penguins data contained in the penguins data set from the palmerpenguins package.\nThe first thing we do to understand a data set is to read the help file on it. (We’ve already done this for the penguins data.) Of course, this only works for data files that come with R or with a package that can be loaded into R. If you are using R to analyze your own data, presumably you don’t need a help file. And if you’re analyzing data from another source, you’ll have to go to that source to find out about the data.\nWhen you read the help file for penguins, you may have noticed that it described the “Format” as being “A tibble with 344 rows and 8 variables.” What is a “tibble”?\nThe word “tibble” is an R-specific term that describes data organized in a specific way. A more common term is “data frame” (or sometimes “data table”). The idea is that in a data frame, the rows and the columns have very specific interpretations.\nEach row of a data frame represents a single object or observation. So in the penguins data, each row represents a penguin. If you have survey data, each row will usually represent a single person. But an “object” can be anything about which we collect data. State-level data might have 50 rows and each row represents an entire state.\nEach column of a data frame represents a variable, which is a property, attribute, or measurement made about the objects in the data. For example, the help file mentions that various pieces of information are recorded about each penguin, like species, bill length, flipper length, body mass, sex, and so on. These are examples of variables. In a survey, for example, the variables will likely be the responses to individual questions.\nWe will use the terms tibble and data frame interchangeably in this course. They are not quite synonyms: tibbles are R-specific implementations of data frames, the latter being a more general term that applies in all statistical contexts. Nevertheless, there are no situations (at least not encountered in this course) where it makes any difference if a data set is called a tibble or a data frame.\nWe can also look at the data frame in “spreadsheet” form. Type\n\nView(penguins)\n\n(Be sure you’re using an upper-case “V” in View.) A new pane should open up in the upper-left corner of the screen. In that pane, the penguins data appears in a grid format, like a spreadsheet. The observations (individual penguins) are the rows and the variables (attributes and measurements about the penguins) are the columns. This will also let you sort each column by clicking on the arrows next to the variable name across the top.\nSometimes, we just need a little peek at the data. Try this to print just a few rows of data to the Console:\n\nhead(penguins)\n\nWe can customize this by specifying the number of rows to print. (Don’t forget about the up arrow trick!)\n\nhead(penguins, n = 10)\n\nThe tail command does something similar, but for data from the last few rows.\n\ntail(penguins)\n\nWhen we’re working with HTML documents like this one, it’s usually not necessary to use View, head, or tail because the HTML format will print the data frame a lot more neatly than it did in the Console. You do not need to type the following code; just look below it for the table that appears.\n\npenguins\n\nYou can scroll through the rows by using the numbers at the bottom or the “Next” button. You can scroll through the variables by clicking the little black arrow pointed to the right in the upper-right corner. The only thing you can’t do here that you can do with View is sort the columns.\nWe want to understand the “structure” of our data. For this, we use the str command. Try it:\n\nstr(penguins)\n\nThis tells us several important things. First it says that we are looking at a data frame with 344 observations of 8 variables. We can isolate those pieces of information separately as well, if needed:\n\nNROW(penguins)\n\n\nNCOL(penguins)\n\nThese give you the number of rows and columns, respectively.\nThe str command also tells us about each of the variables in our data set. We’ll talk about these later.\nWe need to be able to summarize variables in the data set. The summary command is one way to do it:\n\nsummary(penguins)\n\nYou may not recognize terms like “Median” or “1st Qu.” or “3rd Qu.” yet. Nevertheless, you can see why this summary could come in handy.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#understanding-the-variables",
    "href": "01-intro_to_r.html#understanding-the-variables",
    "title": "1  Introduction to R",
    "section": "1.9 Understanding the variables",
    "text": "1.9 Understanding the variables\nWhen we want to look at only one variable at a time, we use the dollar sign to grab it. Try this:\n\npenguins$body_mass_g\n\nThis will list the entire body_mass_g column, in other words, the body masses (in grams) of all the penguins in this particular study. If we only want to see the first few, we can use head like before.\n\nhead(penguins$body_mass_g)\n\nIf we want the structure of the variable body_mass_g, we do this:\n\nstr(penguins$body_mass_g)\n\nNotice the letters int at the beginning of the line. That stands for “integer” which is another word for whole number. In other words, the penguins’ body masses all appear in this data set as whole numbers. There are other data types you’ll see in the future:\n\nnum: This is for general numerical data (which can be integers as well as having decimal parts).\nchr: This means “character”, used for character strings, which can be any sequence of letters or numbers. For example, if the researcher recorded some notes for each penguin, these notes would be recorded in a character variable.\nfactor: This is for categorical data, which is data that groups observations together into categories. For example, species is categorical. These are generally recorded like character strings, but factor variables have more structure because they take on a limited number of possible values corresponding to a generally small number of categories. We’ll learn a lot more about factor variables in future chapters.\n\nThere are other data types, but the ones above are by far the most common that you’ll encounter on a regular basis.\nIf we want to summarize only the variable body_mass_g, we can do this:\n\nsummary(penguins$body_mass_g)\n\nWhile executing the commands above, you may have noticed entries listed as NA. These are “missing” values. It is worth paying attention to missing values and thinking carefully about why they might be missing. For now, just make a mental note that NA is the code R uses for data that is missing. (This would be the same as a blank cell in a spreadsheet.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#projects",
    "href": "01-intro_to_r.html#projects",
    "title": "1  Introduction to R",
    "section": "1.10 Projects",
    "text": "1.10 Projects\nUsing files in R requires you to be organized. R uses what’s called a “working directory” to find the files it needs. Therefore, you can’t just put files any old place and expect R to be able to find them.\nOne way of ensuring that files are all located where R can find them is to organize your work into projects.\n\nIf you are using Posit Cloud, you have already created a project. It will say “Untitled project” at the top of the screen.\n\nClick on the words “Untitled project” and type “intro_stats”. You may skip the next set of bullet points.\n\nIf you are using a local installation of RStudio, look in the far upper-right corner of the RStudio screen. You should see some text that says Project: (None). This means we are not currently in a project and we need to to create one.\n\nOpen the drop-down menu here and select New Project. When the dialog box opens, select New Directory, then New Project. You’ll need to give your project a name. In this case, type intro_stats for the “Directory name”. Leave everything else alone and click Create Project. You will see the screen refresh and R will restart. If everything worked the way it should, creating a new project will create a new folder, put you in that folder, and automatically make it your working directory.\n\n\nIn general, project names should be descriptive—they should still remind you in several years what the project was about. The only thing to remember is that project names and file names should not have any spaces in them. In fact, you should avoid other kinds of special characters as well, like commas, number signs, etc. Stick to letters and numerals and you should be just fine. If you want a multi-word project name or file name, I recommend using underscores. R will allow you to name projects with spaces and modern operating systems are set up to handle file names with spaces, but there are certain things that either don’t work at all or require awkward workarounds when file names have spaces.\nYou will see a file in the Files pane with file extension .Rproj, but you should never touch that file. It’s just for RStudio to keep track of your project details.\nAny additional files you need for your project should be placed in this directory. In all future chapters, the first thing you will do is download the chapter file from the book website and place it here in your project folder. If you are using RStudio through a web browser, you’ll need to upload files to your project folder using the “Upload” button in the Files tab. If you have installed R and RStudio on your own machine, you’ll need to navigate your system to find the downloaded file and move or copy it to your project working directory. (It’s likely in a folder called “Downloads”. But if it’s not and you need to find it elsewhere, this is done most easily using File Explorer in Windows and the Finder in MacOS.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#conclusion",
    "href": "01-intro_to_r.html#conclusion",
    "title": "1  Introduction to R",
    "section": "1.11 Conclusion",
    "text": "1.11 Conclusion\nIt is often said that there is a steep learning curve when learning R. This is true to some extent. R is harder to use at first than other types of software. Nevertheless, in this course, we will work hard to ease you over that first hurdle and get you moving relatively quickly. Don’t get frustrated and don’t give up! Learning R is worth the effort you put in. Eventually, you’ll grow to appreciate the power and flexibility of R for accomplishing a huge variety of statistical tasks.\nOnward and upward!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "01-intro_to_r.html#footnotes",
    "href": "01-intro_to_r.html#footnotes",
    "title": "1  Introduction to R",
    "section": "",
    "text": "The official spec says that a valid variable name “consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number.”↩︎\nIf you get an authorization error, that means you are accessing RStudio through a managed local server and you’ll need your admin to install the package for you.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html",
    "href": "02-using_quarto-web.html",
    "title": "2  Using Quarto",
    "section": "",
    "text": "2.1 Introduction\nThis chapter will teach you how to use Quarto to create quality documents that incorporate text and R code seamlessly.\nFirst, though, let’s make sure you are set up in your project in RStudio.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#introduction",
    "href": "02-using_quarto-web.html#introduction",
    "title": "2  Using Quarto",
    "section": "",
    "text": "2.1.1 Are you in your project?\nIf you followed the directions at the end of the last chapter, you should have created/named a project called intro_stats. Let’s make sure you’re in that project.\nLook at either the top (Posit Cloud) or the upper right corner of the RStudio screen. Does it say intro_stats? If so, congratulations! You are in your project.\nIf you’re not in the intro_stats project,\n\nin Posit Cloud, click on “Your Workspace” and click on the “intro_stats” project you created in the last chapter.\nfor local installations, click on whatever it does say in the upper right corner (probably Project: (None)). You can click “Open Project” but it’s likely that the intro_stats project appears in the drop-down menu in your list of recently accessed projects. So click on the project intro_stats.\n\n\n\n2.1.2 Install new packages\nType the following commands at the Console:1\n\ninstall.packages(\"rmarkdown\")\ninstall.packages(\"tidyverse\")\n\nIt may take a few minutes to install these packages, especially tidyverse, so be patient.\n\n\n2.1.3 Download the Quarto file\nYou need to download this chapter as an Quarto (.qmd) file. Please click the following link to do so:\nhttps://vectorposse.github.io/intro_stats/chapter_downloads/02-using_quarto.qmd\nThe file is now likely sitting in a Downloads folder on your machine (or wherever you have set up for web files to download).\n\nIf you are logged into RStudio on a web browser, go to the Files tab and click the “Upload” button. From there, leave the first box alone (“Target directory”). Click the “Choose File” button and navigate to the folder on your machine containing the file 02_using-quarto.qmd. Select that file and click “OK” to upload the file. Then you will be able to open the file in RStudio simply by clicking on it in the Files pane.\nIf you using RStudio on your own machine, you will need to move the file from your Downloads folder into the intro_stats project directory you created at the end of the last chapter. (Again, if you haven’t created the intro_stats project, please go back to Chapter 1 and follow the directions for doing that.) Moving files around is most easily done using File Explorer in Windows or the Finder in MacOS.\n\nAt this point, you should be reading this text while looking at it in the left pane of RStudio, after opening up the Quarto (.qmd) file and scrolling down until you reach this spot. If you are reading this text while still browsing the book online, be aware that there are several instructions below that won’t make any sense because you’re not looking at the plain text file with all the code in it. Much of the material in this book can be read and enjoyed online, but the real learning comes from downloading the chapter files (starting with Chapter 2—this one) and working through them in RStudio.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#what-is-quarto",
    "href": "02-using_quarto-web.html#what-is-quarto",
    "title": "2  Using Quarto",
    "section": "2.2 What is Quarto?",
    "text": "2.2 What is Quarto?\nBefore we can talk about Quarto documents, we need to talk about markdown.\nMarkdown is a way of using plain text with simple characters to indicate formatting choices in a document. For example, in a markdown file, one can make headers by using number signs (or hashtags as the kids are calling them these days2). The Quarto file itself is just a plain text file. To see the formatting, the file has to be converted to HTML, which is the format used for web pages. (This process is described below.)\nQuarto documents are just text files that use markdown. They also allow you to include R code alongside the text. Here’s an example of a “code chunk”:\n\n1 + 1\n\n[1] 2\n\n\nClick the little dark green, right-facing arrow in the upper-right corner of the code chunk. (The icon I’m referring to is next to a lighter green icon with a downward-facing arrow.) When you “run” the code chunk like this, R produces the appropriate output. We’ll say more about code chunks later in this document.\nThis document—with text and code chunks together—is called an Quarto document.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#rendering-a-document",
    "href": "02-using_quarto-web.html#rendering-a-document",
    "title": "2  Using Quarto",
    "section": "2.3 Rendering a document",
    "text": "2.3 Rendering a document\nThere is a button in the toolbar right above the text that says “Render”. It’s next to a big, blue arrow. Go ahead and click it. See what happens.\nOnce the pretty output is generated, take a few moments to look back and forth between it and the original Quarto document (the plain text in RStudio). You can see some tricks that we won’t need much (embedding web links, making lists, etc.) and some tricks that we will use in every chapter (like R code chunks).\nAt first, you’ll want to work back and forth between the Quarto document and the HTML file to get used to how the formatting in the plain text file get translated to output in the HTML file. You can hit the Render button any time you want to update the HTML output with your most recent changes. After a while, you will look at the HTML file less often and work mostly in the Quarto file, only rendering the final HTML output occasionally, most importantly when you are finished and ready to produce your final draft.\nOne additional benefit of rendering often is that it also automatically saves your progress. If you choose to render less often, you’ll want to save your document manually from time to time just so you don’t lose any work in case of a computer malfunction. (The easiest way to save things in pretty much every piece of software anywhere is to use the keyboard shortcut Ctrl-S in Windows or Cmd-S in MacOS.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#literate-programming",
    "href": "02-using_quarto-web.html#literate-programming",
    "title": "2  Using Quarto",
    "section": "2.4 Literate programming",
    "text": "2.4 Literate programming\nQuarto is one way to implement a “literate programming” paradigm. The concept of literate programming was famously described by Donald Knuth, an eminent computer scientist. The idea is that computer programs should not appear in sterile files that are full of hard-to-read, abstruse lines of computer code. Instead, functional computer code should appear interspersed with writing that explains the code.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#reproducible-research",
    "href": "02-using_quarto-web.html#reproducible-research",
    "title": "2  Using Quarto",
    "section": "2.5 Reproducible research",
    "text": "2.5 Reproducible research\nOne huge benefit of organizing your work into Quarto documents is that it makes your work reproducible. This means that anyone with access to your data and your Quarto document should be able to re-create the exact same analysis you did.\nThis is a far cry from what generally happens in research. For example, if a person does all their work in Microsoft Excel, they make a series of choices in how they format and analyze their data, and all those choices take the form of menu commands that they point and click with a mouse. There is no record of the exact sequence of clicks that took them from point A to B all the way to Z. All they have to show for their work is the “clean” spreadsheet and anything they’ve written down or communicated about their results. If there were any errors along the way, they would be very hard to track down.3\nReproducibility should be a minimum prerequisite for all statistical analysis. Sadly, that is not the case in most of the research world. We are training you to be better.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#structure-of-a-quarto-document",
    "href": "02-using_quarto-web.html#structure-of-a-quarto-document",
    "title": "2  Using Quarto",
    "section": "2.6 Structure of a Quarto document",
    "text": "2.6 Structure of a Quarto document\nLet’s start from the top. Look at the very beginning of the plain Quarto document. (If you’re in RStudio, you are looking at the Quarto document. If you are looking at the pretty HTML file, you’ll need to go back to RStudio.) The section at the very top of the file that starts and ends with three hyphens is called the YAML header. (Search for YAML on the internet it if you really care why.) The title of the document appears already, but you’ll need to substitute your name and date in the obvious place. Scroll up and do that now. Come back here when you’re done.\nYou’ve made changes to the document, so you’ll need to push the “Render” button again. Once that’s done, look at the resulting HTML document. The YAML header has been converted into a nicely formatted document header with the new information you’ve provided.\nNext, you’ll see three colons followed by the text {.callout-note}. Then there is some text that lists R functions that will be introduced in the chapter. (There aren’t any in this chapter, but there usually will be in future chapters.) Then there are three more colons. It’s very important that you do not modify the three colons or any of the text that appears on the same line in the the curly braces next to the colons! This will mess up your ability to Render the document.\nAnother place you will see the three-colon “tags” will be when providing answers to homework questions. It will start with three colons next to {.answer} and end with three colons. While you should be careful not to modify those tags, you can and should modify the plain text that lies between the colon tag fences. Let’s try it:\n\nReplace this text here with something else. (Anything you want to type here is fine.) Then render the document and see how it appears in the HTML file.\n\nTo be clear, the colorful answer boxes are not part of the standard Quarto tool set. The custom code to create those answer boxes is imported from the book’s website.\nWe also have section headers throughout, which in the Quarto file look like:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#section-header",
    "href": "02-using_quarto-web.html#section-header",
    "title": "2  Using Quarto",
    "section": "2.7 Section header",
    "text": "2.7 Section header\nThe hashtags are markdown code for formatting headers. Additional hashtags will create subsections:\n\n2.7.1 Not quite as big\nWe could actually use a single number sign, but # makes a header as big as the title, which is too big and is reserved for the main title of the whole document. Therefore, we will use ## for section headers and ### for subsections.\nYou do need to make sure that there is a blank line before and after each section header. To see why, look at the HTML document at this spot: ## Is this a new section? Do you see the problem?\nPut a blank line before and after the line above that says “Is this a new section?” Render one more time and make sure that the line now shows up as a proper section header.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#other-formatting-tricks",
    "href": "02-using_quarto-web.html#other-formatting-tricks",
    "title": "2  Using Quarto",
    "section": "2.8 Other formatting tricks",
    "text": "2.8 Other formatting tricks\nYou can make text italic or bold by using asterisks. (Don’t forget to look at the HTML to see the result.)\nYou can make bullet-point lists. These can be made with asterisks, but you’ll need to start after a blank line, then put asterisks at the beginning of each new line, followed by a space, as follows:\n\nFirst item\nSecond item\n\nIf you want sub-items, indent at least two spaces and use another asterisk followed by a space.\n\nItem\n\nSub-item\nSub-item\n\nItem\nItem\n\nOr you can make ordered lists. Just use numbers and Quarto will do all the work for you. (Again, make sure you’re starting after a blank line and that there is a space after the periods.)\n\nFirst Item\nSecond Item\nThird Item\n\nWe can make horizontal rules. There are lots of ways of doing this, but we prefer a bunch of asterisks in a row (at least three—we’ve used five for more visual impact in the Quarto document):\n\nThere are many more formatting tricks available. For a good resource on all Quarto stuff, click on this link. And notice in the previous sentence the syntax for including hyperlinks in your document.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#r-code-chunks",
    "href": "02-using_quarto-web.html#r-code-chunks",
    "title": "2  Using Quarto",
    "section": "2.9 R code chunks",
    "text": "2.9 R code chunks\nThe most powerful feature of Quarto is the ability to do data analysis right inside the document. This is accomplished by including R code chunks. An R code chunk doesn’t just show you the R code in your output file; it also runs that code and generates output that appears right below the code chunk.\nAn R code chunk starts with three “backticks” followed by the letter r enclosed in braces, and it ends with three more backticks. (The backtick is usually in the upper-left corner of your keyboard, next to the number 1 and sharing a key with the tilde ~.)\nIn RStudio, click the little dark green, right-facing arrow in the upper-right corner of the code chunk below, just as you did earlier.\n\n# Here's some sample R code\ntest &lt;- c(1, 2, 3, 4)\nsum(test)\n\n[1] 10\n\n\nAfter pushing the dark green arrow, you should notice that the output of the R code appeared like magic. If you Render the HTML output, you should see the same output appear. If you hover your mouse over the dark green arrow, you should see the words “Run Current Chunk”. We’ll call this the Run button for short.\nWe need to address something here that always confuses people new to R and Quarto. A number sign (aka “hashtag”) in a Quarto document gives us section headers. In R code, however, a number sign indicates a “comment” line. In the R code above, the line # Here's some sample R code is not executed as R code. But you can clearly see that the two lines following were executed as R code. So be careful! Number signs inside and outside R code chunks behave very differently.\nTypically, the first code chunk that appears in our document will load any packages we need. We will be using a package called tidyverse (which is really a collection of lots of different packages) throughout the course. We load it now. Click on the Run button (the dark green, right-facing arrow) in the code chunk below. (If you get an error that says “there is no package called tidyverse” that means you failed to install it earlier. Go back and use install.packages as instructed at the top of this document.)\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe output here consists of a bunch of information generated when trying to load the package. These are not errors, even though one section is labeled “Conflicts”. Usually, errors appear with the word “Error”, so it’s typically clear when something just didn’t work. Also note that once you’ve loaded a package, you don’t need to load it again until you restart your R session. For example, if you go back and try to run the code chunk above one more time, the output will disappear. That’s because tidyverse is already loaded, so the second “run” doesn’t actually generate output anymore.\nOkay, let’s do something interesting now. We’ll revisit the penguins data set we introduced in the previous chapter. Remember, though, that this data set also lives in a package that needs to be loaded. Run the code chunk below to load the palmerpenguins package. (There may not be any output. But the command worked silently in the background to load the palmerpenguins package.)\n\nlibrary(palmerpenguins)\n\nLet’s see what happens when we try to run multiple commands in one code chunk:\n\nhead(penguins)\n\n\n  \n\n\ntail(penguins)\n\n\n  \n\n\nstr(penguins)\n\ntibble [344 × 8] (S3: tbl_df/tbl/data.frame)\n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n $ sex              : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n\n\nIf you’re looking at this in RStudio, it’s a bit of a mess. RStudio did its best to give you what you asked for, but there are three separate commands here. The first two (head and tail) print some of the data, so the first two boxes of output are tables showing you the head and the tail of the data. The next one (str) normally just prints some information to the Console. So RStudio gave you an R Console box with the output of this command.\nIf you look at the HTML file, you can see the situation isn’t as bad. Each command and its corresponding output appear nicely separated there.\nNevertheless, it will be good practice and a good habit to get into to put multiple output-generating commands in their own R code chunks. Run the following code chunks and compare the output to the mess you saw above:\n\nhead(penguins)\n\n\n  \n\n\n\n\ntail(penguins)\n\n\n  \n\n\n\n\nstr(penguins)\n\ntibble [344 × 8] (S3: tbl_df/tbl/data.frame)\n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n $ sex              : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n\n\nThis won’t look any different in the HTML file, but it sure looks a lot cleaner in RStudio.\nWhat about the two lines of the first code chunk we ran above?\n\ntest &lt;- c(1, 2, 3, 4)\nsum(test)\n\n[1] 10\n\n\nShould these two lines be separated into two code chunks? If you run it, you’ll see only one piece of output. That’s because the line test &lt;- c(1, 2, 3, 4) works invisibly in the background. The vector test gets assigned, but no output is produced. Try it and see (push the Run button):\n\ntest &lt;- c(1, 2, 3, 4)\n\nSo while there’s no harm in separating these lines and putting them in their own chunks, it’s not strictly necessary. You really only need to separate lines when they produce output. (And even then, if you forget, RStudio will kindly give you multiple boxes of output.)\nSuppose we define a new variable called test2 in a code chunk. FOR PURPOSES OF THIS EXERCISE, DO NOT HIT THE RUN BUTTON YET! But do go look at the HTML file.\n\ntest2 &lt;- c(\"a\", \"b\", \"c\")\ntest2\n\n[1] \"a\" \"b\" \"c\"\n\n\nThe first line defines test2 invisibly. The second line asks R to print the value of test2, and the HTML document shows the vector of three letters printed in the output below the code chunk. DON’T HIT THE RUN BUTTON YET!\nOkay, now go to the Console in RStudio (in the lower left corner of the screen). Try typing test2. You should get an “Error: object ‘test2’ not found.”\nWhy does this happen? The Global Environment doesn’t know about it yet. Look in the upper right corner of the screen, under the “Environment” tab. You should see test, but not test2.\nOkay, NOW GO BACK AND CLICK THE RUN BUTTON IN THE LAST CHUNK ABOVE. The output appears in RStudio below the code chunk and the Global Environment has been updated.\nThe take home message is this:\nBe sure to run all your code chunks in RStudio!\nIn RStudio, look in the toolbar above this document, toward the right. You should see the word “Run” with a little drop-down menu next to it. Click on that drop-down menu and select “Run All”. Do you see what happened? All the code chunks ran again, and that means that anything in the Global Environment will now be updated to reflect the definitions made in the Quarto document.\nIt’s a good idea to “Run All” when you first open a new Quarto document. This will ensure that all your code chunks have their output below them (meaning you don’t have to go through and click the Run button manually for each chunk, one at a time) and the Global Environment will accurately reflect the variables you are using.\nYou can “Run All” from time to time, but it’s easier just to “Run All” once at the beginning, and then Run individual R code chunks manually as you create them.\nNow go back to the Environment tab and find the icon with the little broom on it. Click it. You will get a popup warning you that you about to “remove all objects from the environment”. Click “Yes”. Now the Global Environment is empty. Go back to the “Run” menu and select “Run All”. All the objects you defined in the Quarto document are back.\nClearing out your environment can be useful from time to time. Maybe you’ve been working on a chapter for a while and you’ve tried a bunch of stuff that didn’t work, or you went back and changed a bunch of code. Eventually, all that junk accumulates in your Global Environment and it can mess up your Quarto document. For example, let’s define a variable called my_variable.\n\nmy_variable &lt;- 42\n\nThen, let’s do some calculation with my_variable.\n\nmy_variable * 2\n\n[1] 84\n\n\nPerhaps later you decide you don’t really need my_variable. Put a hashtag in front of the code my_variable &lt;- 42 to comment it out so that it will no longer run, but don’t touch the next code chunk where you multiply it by 2. Now try running the code chunk with my_variable * 2 again. Note that my_variable is still sitting in your Global Environment, so you don’t get any error messages. R can still see and access my_variable.\nNow go to the “Run” menu and select “Restart R and Run All Chunks”. This clears the Global Environment and runs all the R code starting from the top of the Quarto document. This time you will get an error message: object 'my_variable' not found. You’ve tried to calculate with a variable called my_variable that doesn’t exist anymore. (The line in which it was defined has been commented out.)\nIt’s best to make sure all your code chunks will run when loaded from a clean R session. The “Restart R and Run All Chunks” option is an easy way to both clear your environment and re-run all code chunks. You can do this as often as you want, but you will definitely want to do this one last time when you are done. At the end of the chapter, when you are ready to prepare the final draft, please select “Restart R and Run All Chunks”. Make sure everything still works!\nTo get rid of the error above, uncomment the line my_variable &lt;- 42 by removing the hashtag you added earlier.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#inline-r-commands",
    "href": "02-using_quarto-web.html#inline-r-commands",
    "title": "2  Using Quarto",
    "section": "2.10 Inline R commands",
    "text": "2.10 Inline R commands\nYou don’t need a standalone R code chunk to do computations. One neat feature is the ability to use R to calculate things right in the middle of your text.\nHere’s an example. Suppose we wanted to compute the mean body mass (in grams) for the penguins in the penguins data set. We could do this:\n\nmean(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 4201.754\n\n\n(The na.rm = TRUE part is necessary because two of the penguins are missing body mass data. More on missing data in future chapters.)\nBut we can also do this inline by using backticks and putting the letter r inside the first backtick. Go to the HTML document to see how the following sentence appears:\nThe mean body mass for penguins in the penguins data set is 4201.754386 grams.\nYou can (and should) check to make sure your inline R code is working by checking the HTML output, but you don’t necessarily need to go to the HTML file to find out. In RStudio, click so that the cursor is somewhere in the middle of the inline code chunk in the paragraph above. (In other words, click on some part of the text in between the backticks.) Now hit Ctrl-Enter or Cmd-Enter (PC or Mac respectively). A little box should pop up that shows you the answer!\nNotice that, in addition to the inline R command that calculated the mean, we also enclosed penguins in backticks to make it stand out in the output. We’ll continue to do that for all computer commands and R functions. But to be clear, putting a word in backticks is just a formatting trick. If you want inline R code, you also need the letter r followed by a space inside the backticks.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#inline-r-command-errors",
    "href": "02-using_quarto-web.html#inline-r-command-errors",
    "title": "2  Using Quarto",
    "section": "2.11 Inline R command errors",
    "text": "2.11 Inline R command errors\nWorking with inline code is trickier than working with code chunks. When a code chunk fails, the error message appears right there below the chunk. When inline code fails, it manifests in more subtle ways.\nObserve the simple inline code below:\n5\nThis code works just fine. (Test this yourself by clicking somewhere between the backticks and hitting Ctrl-Enter or Cmd-Enter.)\nHit the Render button and scroll down in the HTML document to see what appears here.\nNow go up and change the inline code by adding a percent sign (%) after the 3 (so it will look like 2+3%).\nClick somewhere between the backticks and hit Ctrl-Enter or Cmd-Enter. You should get an error.\nNext, go to the Run menu and select “Restart R and Run All Chunks.” You get no errors. This makes sense because all the code chunks are working fine. The broken code is inline, not inside a code chunk.\nNow try to hit the Render button. The “Background Jobs” tab will stay open with a bunch of error text. Scroll up a little in that error text until you see\nFailed to parse the inline R code\nThat’s the only hint we have as to where the problem might live. We happen to know where to find the offending code, but imagine this code were buried in the middle of some long document.\nThe easiest solution is to use Ctrl-F or Cmd-F. This will open the “Find” tool. Start typing “2+3%” and it will take you to the problematic spot.\nFix the error by deleting the percent sign. Now hit the Render button again to make sure the problem really got fixed and that the output now appears correctly in the HTML document.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#copying-and-pasting",
    "href": "02-using_quarto-web.html#copying-and-pasting",
    "title": "2  Using Quarto",
    "section": "2.12 Copying and pasting",
    "text": "2.12 Copying and pasting\nIn future chapters, you will be shown how to run statistical analyses using R. Each chapter will give extensive explanations of the statistical concepts and demonstrations of the necessary R code. Afterwards, there will be one or more exercises that ask you to apply your new-found knowledge to run similar analyses on your own with different data.\nThe idea is that you should be able to copy and paste the R code from the previously worked examples. But you must be thoughtful about how you do this. The code cannot just be copied and pasted blindly. It must be modified so that it applies to the exercises with new data. This requires that you understand what the code is doing. You cannot effectively modify the code if you don’t know which parts to modify.\nThere will also be exercises in which you are asked to provide your own explanations and interpretations of your analyses. These should not be copied and pasted from any previous work. These exercises are designed to help you understand the statistical concepts, so they must be in your own words, using your own understanding.\nIn order to be successful in these chapters, you must do the following:\n\nRead every part of the chapter carefully!\n\n\nIt will be tempting to skim over the paragraphs quickly and just jump from code chunk to code chunk. This will be highly detrimental to your ability to gain the necessary understanding—not just to complete the chapter, but to succeed in statistics overall.\n\n\nCopy and paste thoughtfully!\n\n\nNot every piece of code from the early part of the chapter will necessarily apply to the later exercises. And the code that does apply will need to be modified (sometimes quite heavily) to be able to run new analyses. Your job is to understand how the code works so that you can make changes to it without breaking things. If you don’t understand a piece of code, don’t copy and paste it until you’ve read and re-read the earlier exposition that explains how the code works.\n\nOne final note about copying and pasting. Sometimes, people will try to copy and paste code from the HTML output file. This is a bad idea. The HTML document uses special characters to make the output look pretty, but these characters don’t actually work as plain text in a Quarto document. The same applies to things copied and pasted from a Word document or another website. If you need to copy and paste code, be sure to find the plain text Quarto file (the one with the .qmd extension here in RStudio) and copy and paste from that.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#conclusion",
    "href": "02-using_quarto-web.html#conclusion",
    "title": "2  Using Quarto",
    "section": "2.13 Conclusion",
    "text": "2.13 Conclusion\nThat’s it! There wasn’t too much you were asked to do for this assignment that will actually show up in the HTML output. (Make sure you did do the three things that were asked of you, however: one was adding your name and the date to the YAML header, one was typing something in the blue answer box, and the last was to make a section header appear properly.) As you gain confidence and as we move into more serious stats material, you will be asked to do a lot more.\n\n2.13.1 Preparing and submitting your assignment\nIf you look in your project folder, you should see (at least) three files:\n[a file with a .Rproj extension, either project.Rproj or intro_stats.Rproj]\n02-using_quarto.qmd\n02-using_quarto.html\nThe first file (with extension .Rproj) you were instructed never to touch.\nThe next file has extension .qmd. This is your Quarto file. It’s the file you’re looking at right now. It is really nothing more than a plain text file, although when you open it in RStudio, some magic allows you to see the output from the code chunks you run.\nFinally, you have a file with extension .html. This is the pretty output file generated when you hit the “Render” button. This is the “final product” of your work.\n(If you happen to see other files or folders in your project folder, you should ignore those and not mess with them.)\nThere are several steps that you should follow at the end of each of every chapter.\n\nFrom the “Run” menu, select “Restart R and Run All Chunks”.\nDeal with any code errors that crop up. Repeat steps 1–2 until there are no more code errors.\nSpell check your document by clicking the icon with “ABC” and a check mark.\nHit the “Render” button one last time to generate the final draft of the HTML file. (If there are errors here, you may need to go back and fix broken inline code or other markdown issues.)\nProofread the HTML file carefully. If there are errors, go back and fix them, then repeat steps 1–5 again.\n\nIf you have completed this chapter as part of a statistics course, follow the directions you receive from your professor to submit your assignment.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "02-using_quarto-web.html#footnotes",
    "href": "02-using_quarto-web.html#footnotes",
    "title": "2  Using Quarto",
    "section": "",
    "text": "If you get an authorization error, that means you are accessing RStudio through a managed local server and you’ll need your admin to install the package for you.↩︎\nAlso called “pound signs” or “octothorpes”. This is also an example of formatting a footnote!↩︎\nIf you think these errors are trivial, Google ``Reinhart and Rogoff Excel error’’ to read about the catastrophic consequences of seemingly trivial Excel mistakes.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using Quarto</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html",
    "href": "03-categorical_data-web.html",
    "title": "3  Categorical data",
    "section": "",
    "text": "3.1 Introduction\nIn this chapter, we’ll learn about categorical data and how to summarize it using tables and graphs.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#introduction",
    "href": "03-categorical_data-web.html#introduction",
    "title": "3  Categorical data",
    "section": "",
    "text": "3.1.1 Install new packages\nType the following at the Console:\ninstall.packages(\"janitor\")\n\n\n3.1.2 Download the Quarto file\nLook at either the top (Posit Cloud) or the upper right corner of the RStudio screen to make sure you are in your intro_stats project.\nThen click on the following link to download this chapter as a Quarto file (.qmd).\nhttps://vectorposse.github.io/intro_stats/chapter_downloads/03-categorical_data.qmd\nOnce the file is downloaded, move it to your project folder in RStudio and open it there.\n\n\n3.1.3 Restart R and run all chunks\nIn RStudio, in the toolbar above this document, find the “Run” drop-down menu and select “Restart R and Run All Chunks.”\nThis does two important things:\n\nR will restart. This will clear out the Global Environment and provide a fresh session for this new assignment. None of the clutter from previous chapters will be there to mess up your work in this chapter.\nAll the code chunks in this document will run so that you can see the output as you scroll past it. This saves you some effort in having to click the little green “Run” button in each code chunk as you come across it. (Also, if you forget to run one, that could cause errors later on, so this way, all the variables you need will be in the Global Environment for when they’re needed later.) You will still need to click the green arrow for new code chunks that you create, of course.\n\nAt the end of the assignment, you will “Restart R and Run All Chunks” once again to make sure that everything works smoothly and there are no lingering errors.\n\n\n3.1.4 Load packages\nWe load the tidyverse package since it also loads the ggplot2 package that we’ll use throughout the course to make graphs. It also loads several other packages, for example, one called dplyr to give us a command called mutate, and another called forcats to give us as_factor. (These will all be explained later.) The janitor package gives us the tabyl command for creating nice tables. Finally, We load the palmerpenguins package to work with the penguin data.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\nlibrary(palmerpenguins)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#categorical-data",
    "href": "03-categorical_data-web.html#categorical-data",
    "title": "3  Categorical data",
    "section": "3.2 Categorical data",
    "text": "3.2 Categorical data\nData comes in different types depending on what is being measured. When people think of “data”, they often imagine numerical data, consisting of numbers. But there are other kinds of data as well.\nIn this chapter, we focus on categorical data that groups observations into categories.\nFor example, if we record the species of a penguin, that is not a number. It’s a word that classifies that penguin into one of a finite number of types. Whenever you see words in a data set, there’s a good chance that you’re looking at categorical data.\nEven “numbers” can sometimes represent categorical data. For example, suppose in a survey there is a Yes/No question. Instead of seeing the words “Yes” or “No”, though, you might see a data set with ones and zeros, where 1 = Yes and 0 = No. The presence of numbers does not automatically make that data numerical. In fact, the data is categorical. Yes and No are categories that sort the survey respondents into two groups based on their responses to a certain question.\nWhat about ZIP codes? They are recorded as numbers, and unlike the Yes/No example above, those numbers aren’t just substitutes for words. Nevertheless, ZIP codes are categorical. They sort addresses into a finite number of groups based on geographic proximity.\nAnother way to think of it is this: can the numerical values of ZIP codes be treated as numbers in any meaningful way? Can you take a sum or an average of ZIP codes? Sure, technically a computer can add up or average a set of ZIP codes, but would the result be a meaningful number? Since the answer is “no” we cannot think of ZIP codes as numbers, even though they are recorded that way.\n\nExercise 1\nThink of another type of data that would be recorded using numbers but should be thought of as categorical data.\n(Recall from the last chapter that you will record your answers to exercises within an answer block like the one below, demarcated with three colons at both ends. Be VERY careful not mess with these three-colon “tags” or with the code {.answer}. If this code gets messed up, it’s likely that your document will not render. Instead, you will delete the words “Please write up your answer here” and replace them with your answer.)\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#factor-variables",
    "href": "03-categorical_data-web.html#factor-variables",
    "title": "3  Categorical data",
    "section": "3.3 Factor variables",
    "text": "3.3 Factor variables\nR uses the term “factor variable” to refer to a categorical variable. Look at the structure of the penguins data below.\n\nstr(penguins)\n\ntibble [344 × 8] (S3: tbl_df/tbl/data.frame)\n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n $ sex              : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n\n\nThe categorical variables species, island, and sex are coded correctly as factor variables.\nThe tidyverse package offers a function called glimpse that effectively does the same thing as str. We’ll use glimpse throughout the rest of the course.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\nExercise 2\nLook at the output of str versus glimpse above. Write down any advantages or disadvantages you see using one versus the other. (You may also want to check the help file for the two commands to see if they offer any clues as to why you might use one over the other.)\n\nPlease write up your answer here.\n\n\nYour data set may already come with its variables coded correctly as factor variables, but often they are not. As described above, numbers are often used to represent categories, so R may think that those variables represent numerical data. Later, we’ll see an example of this and learn how to handle categorical variables that are not coded as factor variables in R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#summarizing-one-categorical-variable",
    "href": "03-categorical_data-web.html#summarizing-one-categorical-variable",
    "title": "3  Categorical data",
    "section": "3.4 Summarizing one categorical variable",
    "text": "3.4 Summarizing one categorical variable\nIf you need to summarize a single categorical variable, a frequency table usually suffices. This is simply a table that counts up all the instances of each category. The word “frequency” is synonymous here with the word “count”.\nWe can use the table command:\n\ntable(penguins$species)\n\n\n   Adelie Chinstrap    Gentoo \n      152        68       124 \n\n\nRecall that the dollar sign means to grab the variable species from the tibble penguins.\nYou can also generate a relative frequency table which is a table that uses proportions or percentages instead of counts.\nNOTE: For purposes of this course, we’re going to be very careful about the terms proportion and percentage. For us, a proportion will always be a number between 0 and 1 whereas a percentage will be between 0 and 100. Calculating a percentage is the same as multiplying a proportion by 100.\nThe table command stops being convenient if you want proportions instead of counts. Instead, we will use the tabyl command from the janitor package that was loaded near the top of the chapter. The syntax for this command is a little different. The tibble goes first, followed by a comma, followed by the variable you want to summarize:\n\ntabyl(penguins, species)\n\n\n  \n\n\n\nNow you get both counts and proportions. Note that in the output above, it’s a little misleading to call the last column “percent”. These are actually proportions, and we would have to multiply by 100 to get percentages.\nIt’s usually nice to have the column totals. We can achieve that by using an adorn function to get them as follows:\n\ntabyl(penguins, species) |&gt;\n  adorn_totals()\n\n\n  \n\n\n\nWe’ll always include the totals at the bottom.\nIf you really want percentages, we can use a different adorn function:\n\ntabyl(penguins, species) |&gt;\n  adorn_pct_formatting()\n\n\n  \n\n\n\nAgain, we’ll also include adorn_totals so that we get the column totals.\n\ntabyl(penguins, species) |&gt;\n  adorn_totals() |&gt;\n  adorn_pct_formatting()\n\n\n  \n\n\n\nThe syntax above looks a little confusing with the unusual |&gt; symbols everywhere. You will learn more about that weird set of symbols in a later chapter. For now, you can just copy and paste this code and make any necessary changes to the tibble and/or variables names as needed.\n\nExercise 3(a)\nUse the tabyl command as above to create a frequency table for the sex of the penguins. Include the column totals at the bottom. (You will also get a relative frequency table for free.)\n\n\n# Add code here to create a frequency table for sex\n\n\n\n\nExercise 3(b)\nIn the table for sex that you just created, what does the row labeled &lt;NA&gt; mean?\n\nPlease write up your answer here.\n\n\n\nExercise 3(c)\nNow create a relative frequency table for sex that reports percentages and not proportions (still including the column totals at the bottom).\n\n\n# Add code here that reports percentages instead of proportions\n\n\n\n\nExercise 3(d)\nIn the previous tables, what is the difference between percent and valid_percent? Why are there two different sets of percentages being computed?\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#graphing-one-categorical-variable",
    "href": "03-categorical_data-web.html#graphing-one-categorical-variable",
    "title": "3  Categorical data",
    "section": "3.5 Graphing one categorical variable",
    "text": "3.5 Graphing one categorical variable\nWhen asked, “What type of graph should I use when graphing a single categorical variable?” the simple answer is “None.” If you do need to summarize a categorical variable, a frequency table usually suffices.\nIf you really, really want a graph, the standard type is a bar chart. But before we can create one, we need to start learning about the very important tool we will use throughout the course for graphing. It’s called ggplot and it’s part of a package called ggplot2.1\nWe don’t have to load the ggplot2 package explicitly because it got loaded alongside a number of other packages when we called library(tidyverse) early on in the chapter.\n\n3.5.1 ggplot\nThe ggplot command is an all-purpose graphing utility. It uses a graphing philosophy derived from a book called The Grammar of Graphics by Leland Wilkinson. The basic idea is that each variable you want to plot should correspond to some element or “aesthetic” component of the graph. The obvious places for data to go are along the y-axis or x-axis, but other aesthetics are important too; graphs often use color, shape, or size to illustrate different aspects of data. Once these aesthetics have been defined, we will add “layers” to the graph. These are objects like dots, boxes, lines, or bars that dictate the type of graph we want to see.\nIn an introductory course, we won’t get too fancy with these graphs. But be aware that there’s a whole field of data visualization that studies clear and interesting ways to understand data graphically.\nIt will be easier to explain the ggplot syntax in the context of specific graph types, so let’s create a bar chart for species.\n\nggplot(penguins, aes(x = species)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nWe’ll walk through this syntax step by step.\n\nThe first argument of the ggplot command is the name of the tibble, in this case, penguins.\nNext we define the aesthetics using aes and parentheses. Inside the parentheses, we assign any variables we want to plot to aesthetics of the graph. For this analysis, we are only interested in the variable species and for a bar chart, the categorical variable typically goes on the x-axis. That’s why it says x = species inside the aes argument.\nFinally, ggplot needs to know what kind of graph we want. Graph types are called “geoms” in the ggplot world, and geom_bar() tells ggplot to add a “bar chart layer”. Adding a layer is accomplished by literally typing a plus sign.\n\nThis can be modified somewhat to give proportions (relative frequencies) on the y-axis instead of counts. Unfortunately, the ggplot syntax is not very transparent here. My recommendation is to copy and paste the code below if you need to make a relative frequency bar chart in the future, making the necessary changes to the tibble and variable names, of course.\n\nggplot(penguins, aes(x = species, y = after_stat(prop), group = 1)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nThese bar charts are the graphical analogues of a frequency table and a relative frequency table, respectively.\n\nExercise 4\nIn a sentence or two at most, describe the distribution of species in this data set.\n\nPlease write up your answer here.\n\n\nWhat about pie charts? Just. Don’t.\nSeriously. Pie charts suck: https://medium.com/the-mission/to-pie-charts-3b1f57bcb34a\nOkay, in fairness, here is the opinion of one data visualization researcher who gives a (somewhat qualified) defense of pie charts (in certain narrow situations): https://eagereyes.org/pie-charts\nWe will not be creating any pie charts in this course.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#summarizing-two-categorical-variables",
    "href": "03-categorical_data-web.html#summarizing-two-categorical-variables",
    "title": "3  Categorical data",
    "section": "3.6 Summarizing two categorical variables",
    "text": "3.6 Summarizing two categorical variables\nA table summarizing two categorical variables is called a contingency table (or pivot table, or cross-tabulation, or probably several other terms as well).\nFor example, we might pose the following question: is the distribution of sex among penguins in our data more or less balanced across the three species?\nWhen we work with two variables, typically we think of one variable as response and the other as predictor. The response variable is usually the variable of main interest. A predictor variable is another attribute that might predict or explain more about the response variable. Often, the predictor variable is used to divide our data into groups for comparison.\nFor example, our question is concerned with the sex distribution of penguins. We could create a relative frequency table of sex alone to see if male and female penguins are balanced in the data. In fact, you did that very thing above and saw that, indeed, there were roughly equal numbers of male and female penguins. But is that still true when we divide up the data into the three groups representing the separate species?\nTwo variables are called associated when there is a relationship between them. For example, if sex and species were associated, then the distribution of sex would change depending on the species. Maybe one species of penguin had more females and another had fewer females available to the researchers who compiled this data. Our prediction of the sex distribution would change based on the value of the predictor (grouping) variable species.\nOn the other hand, two variables that are not associated are called independent. Independent variables are not related. If the sex distribution were the same across all species, then knowledge of the species would not change our predictions about the sex of a penguin. It wouldn’t matter because there was no relationship between sex and species.\nMost research questions that involve two or more variables are fundamentally questions of whether a response variable is associated with one or more predictor variables, or whether they are independent.\nLet’s look at a contingency table. The tabyl command will place the first variable listed across the rows and the second one listed down the columns. Since we always include column totals, we want the predictor variable to be the column variable so we can see how the predictor groups are distributed in the data. Always list the response variable first.\n\ntabyl(penguins, sex, species) |&gt;\n  adorn_totals()\n\n\n  \n\n\n\nEach column is a group, and our question is whether the distribution of sexes in each column is similar.\nThe last row of totals is called the marginal distribution (because it sits in the “margin” of the contingency table). It is equivalent to a frequency table for species.\n\nExercise 5\nCounts can be misleading. For example, there are 73 female Adelie penguins, but only 34 female Chinstrap penguins. Does that mean that Adelie penguins are more likely to be female than Chinstrap penguins? Why or why not?\n\nPlease write up your answer here.\n\n\nA more fair way to compare across columns is to create relative frequencies. We can do this with a slightly different adorn command. The following code says that we want to compute column proportions (yes, I know the command is called adorn_percentages, but these are proportions):\n\ntabyl(penguins, sex, species) |&gt;\n  adorn_totals() |&gt;\n  adorn_percentages(\"col\")\n\n\n  \n\n\n\nIt’s important to put “col” inside the adorn_percentages command. Look what happens if we forget:\n\n# We should not do this!\ntabyl(penguins, sex, species) |&gt;\n  adorn_totals() |&gt;\n  adorn_percentages()\n\n\n  \n\n\n\nWhat are these proportions? The next code chunk will reveal the secret:\n\n# We should not do this!\ntabyl(penguins, sex, species) |&gt;\n  adorn_totals() |&gt;\n  adorn_percentages(\"row\")\n\n\n  \n\n\n\nThe default for adorn_percentages is to create row proportions. But these are not helpful to us. We are not grouping by sex and then trying to figure out the distribution of species within each sex. It’s the opposite of our research question.\nIf we actually want percentages instead of proportions, we need one more line of code. This command—adorn_pct_formatting—is the same as we used before with frequency tables.\n\ntabyl(penguins, sex, species) |&gt;\n  adorn_totals() |&gt;\n  adorn_percentages(\"col\") |&gt;\n  adorn_pct_formatting()\n\n\n  \n\n\n\nNow we can see that each column adds up to 100%. In other words, each species is now on equal footing, and only the distribution of sexes within each group matters.\n\n\nExercise 6(a)\nWhat percentage of Adelie penguins are male? What percentage of Chinstrap penguins are male? What percentage of Gentoo penguins are male?\n\nPlease write up your answer here.\n\n\n\nExercise 6(b)\nDoes sex appear to be associated with species for the penguins in this data set? Or are these variables independent? Why?\n\nPlease write up your answer here.\n\n\nThe islands of Antarctica on which the penguins were observed and measured are recorded in the variable called island. Is the distribution of the three species of penguin the same (or similar) on the three islands?\n\n\nExercise 7(a)\nChoosing which variables play the roles of response and predictor can be tricky. For the question above, with species and island, which is response and which is predictor?\nOne way to think about this is to ask the following two questions and see which one is closer to the question asked:\n\nGiven information about the species, are you interested in which island the penguin lives on? If so, species is a predictor and island is response. (You are using species to predict island.)\nGiven information about the island, are you interested in the species of the penguin? If so, island is a predictor and species is response. (You are using island to predict species.)\n\nAnother way to think of this is to determine the grouping variable. Which variable is being used to divide the penguins into groups first? That will be the predictor variable.\n\nPlease write up your answer here.\n\n\n\nExercise 7(b)\nCreate a contingency table with percentages. List species first, followed by island. (Hey, that’s a hint in case you need to go back and change your answer to part (a).) Include column totals as well. (They should all be 100%.)\n\n\n# Add code here to create a contingency table with percentages.\n\n\n\n\nExercise 7(c)\nFinally, comment on the association or independence of the two variables.\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#graphing-two-categorical-variables",
    "href": "03-categorical_data-web.html#graphing-two-categorical-variables",
    "title": "3  Categorical data",
    "section": "3.7 Graphing two categorical variables",
    "text": "3.7 Graphing two categorical variables\nA somewhat effective way to display two categorical variables is with a side-by-side bar chart. Here is the ggplot code for the relationship between sex and species.\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\nThis is somewhat different from the first ggplot example you saw above, so let’s take a moment to go through it.\n\nThe first argument is the data frame penguins; no mystery there.\nThe second aesthetic x = species also makes a lot of sense. As species is our predictor variable—we’re using species to group the penguins, and then within each species, we’re interested in the sex distribution—species goes on the x-axis.\nHowever, sex does not go on the y-axis! (This is a very common mistake for novices.) The y-axis of a bar chart is always a count or a proportion/percentage, so no variable should ever go on the y-axis of a bar chart. In that case, how does sex enter the picture? Through the use of color! The aesthetic fill = sex says to use the sex variable to shade or “fill” the bars with different colors. You’ll also notice that ggplot makes a legend automatically with the colors so you can see which color corresponds to which value (in this case, “female”, “male”, or “NA” for the missing data).\n\nAnother unusual feature is the argument position = \"dodge\" in the geom_bar layer. Let’s see what happens if we remove it.\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nWe get a stacked bar chart! This is another popular way of displaying two categorical variables, but we don’t tend to prefer it. Notice how difficult it is to compare the number of females across species; since there is no common baseline for the red segments of each bar, it is harder to determine which ones are bigger or smaller. (In this case, it’s fairly clear, but there are plenty of data sets for which the counts might be a lot closer.)\nSo let’s agree to use side-by-side bar charts. There is still one aspect of the side-by-side bar chart that is misleading, though. For example, the red bar for Adelie penguins is bigger than the red bar for Gentoo penguins. Does this mean Adelie penguins are more likely to be female?\nThis is the same issue we identified in an exercise above. To fix this problem, a better option here would be to use relative frequencies (i.e., proportions/percentages within each group) instead of counts on the y-axis. This is analogous to using proportions/percentages in a contingency table. Unfortunately, it is rather difficult to do this with ggplot. A compromise is available: by using position = fill, you can create a stacked bar chart that scales every group to 100%. Making comparisons across groups can still be hard, as explained above for any kind of stacked bar chart, but it works okay if there are only two categories in the response variable (as is almost the case with sex here, although the missing data distorts things a little at the bottom).\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\nThis graph does correctly show that the sexes are pretty much equally balanced across all three species.\n\nExercise 8(a)\nUsing species and island, create a side-by-side bar chart. Be careful, though, to change the sample code above to make sure species is now the response variable (using the fill aesthetic) and that island is the explanatory variable (using x). (Hey, that’s another hint to go back and look at the previous exercise and make sure you got part (a) right!)\n\n\n# Add code here to make a side-by-side bar chart.\n\n\n\n\nExercise 8(b)\nComment on the association or independence of the two variables.\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#recoding-factor-variables",
    "href": "03-categorical_data-web.html#recoding-factor-variables",
    "title": "3  Categorical data",
    "section": "3.8 Recoding factor variables",
    "text": "3.8 Recoding factor variables\nAs mentioned earlier, there are situations where a categorical variable is not recorded in R as a factor variable. Let’s look at the year variable:\n\nglimpse(penguins$year)\n\n int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n\n\nThese appear as integers. Yes, years are whole numbers, but why might this variable be treated as categorical data and not numerical data?\n\nExercise 9(a)\nUse the tabyl command to create a frequency table for year.\n\n\n# Add code here to make a frequency table for year.\n\n\n\n\nExercise 9(b)\nWhy is year better thought of as categorical data and not numerical data (at least for this data set—we’re not claiming years should always be treated as categorical)?\n\nPlease write up your answer here.\n\n\nWhile the tabyl command seemed to work just fine with the year data in integer format, there are other commands that will not work so well. For example, ggplot often fails to do the right thing when a categorical variable is coded as a number. Therefore, we need a way to change numerically coded variables to factors.\nThe code below uses a command called mutate that takes an old variable and creates a new variable. (You’ll learn more about this command in a later chapter. For now, you can just copy and paste this code if you need it again.) The name of the new variable can be anything we want; we’ll just call it year_fct. Then the real work is being done by the as_factor command that converts the numeric year variable into a factor variable.\nObserve the effect below:\n\npenguins &lt;- penguins |&gt;\n  mutate(year_fct = as_factor(year))\nglimpse(penguins)\n\nRows: 344\nColumns: 9\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ year_fct          &lt;fct&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\nExercise 10(a)\nMake a contingency table of the species measured in each year using counts. Use the species variable first, followed by the new factor variable year_fct. (Think about why that order makes sense. We will always list the response variable first so that the categories of interest will be the rows and the groups will be the columns.)\n\n\n# Add code here to make a contingency table for species and year with counts.\n\n\n\n\nExercise 10(b)\nMake a contingency table of the species measured in each year using column percentages (not proportions). (Again, be sure to use the new factor variable year_fct, not the old variable year.)\n\n\n# Add code here to make a contingency table for species and year with percentages.\n\n\n\n\nExercise 10(c)\nHow similar or dissimilar are the distributions of species across the three years of the study?\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#plotting-summary-data",
    "href": "03-categorical_data-web.html#plotting-summary-data",
    "title": "3  Categorical data",
    "section": "3.9 Plotting summary data",
    "text": "3.9 Plotting summary data\nEverything we did above was summarizing raw data; that is, the data consisted of all the observations for each individual penguin. Often, though, when you find data out in the wild, that data will be summarized into a table already and you may not have access to the raw data.\nFor example, let’s suppose that you found some data online, but it looked like this:\n\n\n\nspecies\ncount\n\n\n\n\nAdelie\n152\n\n\nChinstrap\n68\n\n\nGentoo\n124\n\n\n\nThis raises two questions:\n\nHow would you get this data into R?\nHow would you plot the data?\n\nTo answer the first question, we show you how to create your own tibble. Here is the syntax:\n\npenguin_species_table &lt;- tibble(\n  species = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n  count = c(152, 68, 124)\n)\npenguin_species_table\n\n\n  \n\n\n\nBasically, the tibble command creates a new tibble. Then each column of data must be entered manually as a “vector” using the c to group all the data values together for each column. Be careful about the placement of quotation marks, commas, and parentheses.\nOnce we have our summary data, we want to make a bar chart. But this won’t work:\n\nggplot(penguin_species_table, aes(x = species)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\nExercise 12\nExplain what went wrong with the previous command? Why does ggplot think that each species has count 1? (Hint: in tibble you just created, look at the species column. What if R thinks this is raw data where each row represents a single penguin?)\n\nPlease write up your answer here.\n\n\nInstead, we need to use geom_col. This works a lot like geom_bar except that it also requires a y value in its aesthetics to force the command to look for the counts in some other variable in the data.\n\nggplot(penguin_species_table, aes(x = species, y = count)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\n\nExercise 13(a)\nUse the tabyl command to create a frequency table for island.\n\n\n# Add code here to create a frequency table for island\n\n\n\n\nExercise 13(b)\nUse the tibble command to create a new tibble manually that contains the frequency data for the island variable. It should have two columns, one called island and the other called count. Name it penguin_island_table.\n\n\n# Add code here to create a tibble with frequency data for island\n\n\n\n\nExercise 13(c)\nUse ggplot with geom_col to create a bar chart for island.\n\n\n# Add code here to create a bar chart for island",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#recovering-raw-data-from-tables",
    "href": "03-categorical_data-web.html#recovering-raw-data-from-tables",
    "title": "3  Categorical data",
    "section": "3.10 Recovering raw data from tables",
    "text": "3.10 Recovering raw data from tables\n\n3.10.1 Recovering raw data from a frequency table\nSometimes we come across summary data instead of raw data. We’ve learned how to manually create tibbles with that summary data and use geom_col instead of geom_bar to graph it, but sometimes it is also useful to recover what the raw data would have been. Fortunately there are R tools to do exactly that.\nWe’ll continue with our example penguin_species_table, reprinted here for reference:\n\npenguin_species_table\n\n\n  \n\n\n\nFrom this table, we know what the raw data for this variable should look like: there should be 152 rows that say “Adelie,” 68 rows that say “Chinstrap,” and 124 rows that say “Gentoo.” It would be very annoying, though, to make that whole tibble by hand.\nThe hero of the day is the function uncount from the tidyr package (loaded automatically when you loaded the tidyverse package):\n\npenguin_species_raw &lt;- penguin_species_table |&gt;\n  uncount(count)\npenguin_species_raw\n\n\n  \n\n\n\nClick through the rows of this table and you’ll see that it’s exactly what we wanted: “Adelie” is repeated 152 times, “Chinstrap” is repeated 68 times, and “Gentoo” is repeated 124 times. Neat!\n\n\n3.10.2 Recovering raw data from a contingency table\nThis strategy also works, with some modifications, for recovering the raw data presented in a contingency table. Previously, we saw the following contingency table showing the counts of each species broken down by sex:\n\n\n\nsex\nAdelie\nChinstrap\nGentoo\n\n\n\n\nfemale\n73\n34\n58\n\n\nmale\n73\n34\n61\n\n\n\n(Note: we’ve removed the unruly penguins who did not allow their sex to be determined.)\nAgain, we can imagine what the raw data would look like: there would be 73 rows where the species variable would say “Adelie” and the sex variable would say “female,” then 34 rows where the species variable would say “Chinstrap” and the sex variable would say “female,” and so on.\nWe can start by building a tibble with this information in the same way we built the tibble of penguin species counts. Note that the species labels now become the column headers.\n\npenguin_species_sex_table &lt;- tibble(\n  sex = c(\"female\", \"male\"),\n  Adelie = c(73, 73),\n  Chinstrap = c(34, 34),\n  Gentoo = c(58, 61)\n)\npenguin_species_sex_table\n\n\n  \n\n\n\nIn order for the uncount function to work correctly, we need to have all the counts in a single column, but since this is a contingency table, our counts are spread out across several columns. To solve this problem, we’ll need to “pivot” the columns, turning them into rows. The command is called pivot_longer. (There is also a pivot_wider command that turns rows into columns, but we won’t need that one.)\n\npenguin_species_sex_table |&gt;\n  pivot_longer(cols = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"))\n\n\n  \n\n\n\nIf we want a little more control over the names of the newly created columns, we can add those as follows:\n\npenguin_species_sex_table |&gt;\n  pivot_longer(cols = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n               names_to = \"species\",\n               values_to = \"count\")\n\n\n  \n\n\n\nNow our data is in a form that uncount can handle. And indeed, we can assemble all these steps together into a pipeline. First, we should build the tibble, then pivot the tibble, and finally uncount to get back to the raw data. We want store the result as a new tibble.\nHere are all the steps put together:\n\n# This is the summary data in contingency table form,\n# stored as a tibble\npenguin_species_sex_table &lt;- tibble(\n  sex = c(\"female\", \"male\"),\n  Adelie = c(73, 73),\n  Chinstrap = c(34, 34),\n  Gentoo = c(58, 61)\n)\n\n# This is the pipeline that starts with the contingency table\n# and produces the raw data, one penguin per row\npenguin_species_sex_table |&gt;\n  pivot_longer(cols = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n               names_to = \"species\",\n               values_to = \"count\") |&gt;\n  uncount(count) -&gt; penguin_species_sex_raw\n\npenguin_species_sex_raw\n\n\n  \n\n\n\nIndeed, this new tibble looks just like how we wanted it to look.\n(Notice the clever use of the arrow -&gt; in the last line of the pipeline. We are used to assigning variables with &lt;- and the name of the new variable on the left. But we can also use `-&gt; at the end of the line with the name of the new variable on the right!)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#publication-ready-graphics",
    "href": "03-categorical_data-web.html#publication-ready-graphics",
    "title": "3  Categorical data",
    "section": "3.11 Publication-ready graphics",
    "text": "3.11 Publication-ready graphics\nLet’s go back to the first relative frequency bar chart from this chapter.\n\nggplot(penguins, aes(x = species, y = after_stat(prop), group = 1)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nThe variable name species is already informative, but the y-axis is labeled with “prop”. Also note that this graph could use a title. We can do all this with labs (for labels). Observe:\n\nggplot(penguins, aes(x = species, y = after_stat(prop), group = 1)) +\n  geom_bar() +\n  labs(title = \"Distribution of species\",\n       y = \"Proportion\",\n       x = \"Species\")\n\n\n\n\n\n\n\n\n\n3.11.1 Using colorblind-friendly palettes\nThe default color scheme used in ggplot2 is not designed to be friendly to folks who experience various forms of colorblindness (including the author of this book, who experiences deuteranomaly, a relatively common form of red-green colorblindness).\nAs a reminder, this was our side-by-side bar chart, now including labels:\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"dodge\") +\n  labs(title = \"Sex of penguins by species\",\n       y = \"Count\",\n       x = \"Species\",\n       fill = \"Sex\")\n\n\n\n\n\n\n\n\nA simple fix is to add one line of code to the ggplot call:\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"dodge\") +\n  labs(title = \"Sex of penguins by species\",\n       y = \"Count\",\n       x = \"Species\",\n       fill = \"Sex\") +\n  scale_fill_viridis_d()\n\n\n\n\n\n\n\n\nTo a person with typical color perception, this may feel a little like it’s burning your eyeballs. But to a person with severe colorblindness, this contrast is very helpful for seeing these two categories clearly.\nNotice that the NA values above blend in with the background, so they’re not visible. This is fixed by putting black borders around the bars:\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"dodge\", color = \"black\") +\n  labs(title = \"Sex of penguins by species\",\n       y = \"Count\",\n       x = \"Species\",\n       fill = \"Sex\") +\n  scale_fill_viridis_d()\n\n\n\n\n\n\n\n\nIt’s also possible to use grayscale. This is often a requirement for publishing in print journals. If we use gray (spelled “grey” in ggplot code) for the bars, it would also be best to turn off the gray background using a “theme” (called theme_bw).\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"dodge\", color = \"black\") +\n  labs(title = \"Sex of penguins by species\",\n       y = \"Count\",\n       x = \"Species\",\n       fill = \"Sex\") +\n  scale_fill_grey() +\n  theme_bw()\n\n\n\n\n\n\n\n\nFor some reason, the default color for missing values is red, which is somewhat annoying. It doesn’t require much more code to change that:\n\nggplot(penguins, aes(fill = sex, x = species)) +\n  geom_bar(position = \"dodge\", color = \"black\") +\n  labs(title = \"Sex of penguins by species\",\n       y = \"Count\",\n       x = \"Species\",\n       fill = \"Sex\") +\n  scale_fill_grey(na.value = \"white\") +\n  theme_bw()\n\n\n\n\n\n\n\n\nLearn more about the various forms of colorblindness here: https://my.clevelandclinic.org/health/diseases/11604-color-blindness\nAnd here’s a surprisingly entertaining (albeit, a bit technical in parts) video of a conference presentation given by the researchers who developed the Viridis color palette: https://youtu.be/xAoljeRJ3lU?si=ARxA7ZFkj_2qp6kL\n\nExercise 11\nModify the following side-by-side bar chart by adding a title and labels for both the fill variable and the x-axis variable. Change the y-axis label to “Count” with an uppercase “C”. Use the Viridis color palette with black borders around the bars.\n\n\n# Modify the following side-by-side bar chart by adding a title and \n# labels for both the fill variable and the x-axis variable.\n# Change the y-axis label to \"Count\" with an uppercase \"C\".\n# Use the Viridis color palette with black borders around the bars.\nggplot(penguins, aes(fill = species, x = island)) +\n  geom_bar(position = \"dodge\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#conclusion",
    "href": "03-categorical_data-web.html#conclusion",
    "title": "3  Categorical data",
    "section": "3.12 Conclusion",
    "text": "3.12 Conclusion\nYou can summarize a single categorical variable using a frequency table. For only one categorical variable, a graph is usually overkill, but if you really want a graph, the bar chart is the best option. Both raw counts and proportions/percentages can be useful.\nWe use contingency tables to summarize two categorical variables. Unless groups are of equal size, raw counts can be incredibly misleading here. You should include proportions/percentages to be able to compare the distributions across groups. If the proportions/percentages are roughly the same, the variables are more likely to be independent, whereas if the proportions/percentages are different, there may be an association between the variables.\nFor graphing two categorical variables, the best choice is usually a side-by-side bar chart. A stacked bar chart will also work, especially if using relative frequencies on the y-axis, but it can be hard to compare across groups when the response variable has three or more categories.\nSometimes we come across categorical data that is recorded using numbers. Many R commands will not work properly if they expect factors and receive numbers, so we use the mutate command to create a new variable along with as_factor to convert the numbers to categories.\nSometimes we come across summary data instead of raw data. We can then manually create tibbles with that summary data and use geom_col instead of geom_bar to graph it. We can even reproduce the raw data by using the uncount command on tables.\nFinally, there are various modifications we can make to ggplot code to make our graphs more professional, clear, and friendly for those experiencing colorblindness.\n\n3.12.1 Preparing and submitting your assignment\n\nFrom the “Run” menu, select “Restart R and Run All Chunks”.\nDeal with any code errors that crop up. Repeat steps 1–2 until there are no more code errors.\nSpell check your document by clicking the icon with “ABC” and a check mark.\nHit the “Render” button one last time to generate the final draft of the HTML file. (If there are errors here, you may need to go back and fix broken inline code or other markdown issues.)\nProofread the HTML file carefully. If there are errors, go back and fix them, then repeat steps 1–5 again.\n\nIf you have completed this chapter as part of a statistics course, follow the directions you receive from your professor to submit your assignment.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "03-categorical_data-web.html#footnotes",
    "href": "03-categorical_data-web.html#footnotes",
    "title": "3  Categorical data",
    "section": "",
    "text": "Why the “2”? It’s a long story. Google it if you’re interested in the history of the development of the ggplot2 package.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Categorical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html",
    "href": "04-numerical_data-web.html",
    "title": "4  Numerical data",
    "section": "",
    "text": "4.1 Introduction\nIn this chapter, we’ll learn about numerical data and how to summarize it through summary statistics and graphs.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#introduction",
    "href": "04-numerical_data-web.html#introduction",
    "title": "4  Numerical data",
    "section": "",
    "text": "4.1.1 Install new packages\nThere are no new packages used in this chapter.\n\n\n4.1.2 Download the Quarto file\nLook at either the top (Posit Cloud) or the upper right corner of the RStudio screen to make sure you are in your intro_stats project.\nThen click on the following link to download this chapter as a Quarto file (.qmd).\nhttps://vectorposse.github.io/intro_stats/chapter_downloads/04-numerical_data.qmd\nOnce the file is downloaded, move it to your project folder in RStudio and open it there.\n\n\n4.1.3 Restart R and run all chunks\nIn RStudio, select “Restart R and Run All Chunks” from the “Run” menu.\n\n\n4.1.4 Load packages\nWe load the tidyverse package to get ggplot2 and the palmerpenguins package to work with the penguin data.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(palmerpenguins)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#a-note-about-mathematical-notation",
    "href": "04-numerical_data-web.html#a-note-about-mathematical-notation",
    "title": "4  Numerical data",
    "section": "4.2 A note about mathematical notation",
    "text": "4.2 A note about mathematical notation\nFrom time to time, we will use mathematical notation that can’t be typed directly on the keyboard. For example, let’s suppose we want to typeset the quadratic formula, which involves a complicated fraction as well as a square root symbol.\nWhen such notation appears, it will be surrounded by double dollar signs as follows:\n\\[\nx = \\frac{-b \\pm \\sqrt{b^{2} - 4ac}}{2a}\n\\]\nThe Quarto document will interpret this special mathematical notation and show it on the screen as well as in the HTML document.1 If the nicely formatted formula does not appear on your screen, place your cursor anywhere inside the math formula and hit Ctrl-Enter or Cmd-Enter (PC or Mac respectively).\nSometimes, we want such math to appear inline. We can do this with single dollar signs. For example, the distance formula is \\(d = \\sqrt{(x_{2} - x_{1})^{2} + (y_{2} - y_{1})^{2}}\\), a fact you may have learned a long time ago.\nThis will not show up as a formatted equation in the Quarto document, but it will show up in the HTML file. If you want to check that it worked properly without having to render the HTML, you can either hover your cursor over the math formula and wait a second, or you can place your cursor anywhere inside the math formula and hit Ctrl-Enter or Cmd-Enter (PC or Mac respectively) to see a pop-up window showing the mathematical content properly formatted.\nYou will be shown examples of any mathematical notation you need to use in any given chapter, so feel free to copy/paste/modify any math notation you need.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#statistics",
    "href": "04-numerical_data-web.html#statistics",
    "title": "4  Numerical data",
    "section": "4.3 Statistics",
    "text": "4.3 Statistics\nThe word “statistics” has several meanings. On one hand, it’s an entire field of study, as in the subject of this course. More specifically, though, a “statistic” is any kind of numerical summary of data. While there are many ways to summarize numerical data, they mostly fall into two main flavors: measures of center and measures of spread. Measures of center try to estimate some kind of average, middle, or common value in data. Measures of spread try to estimate something like the width, range, variability, or uncertainty of data.\nThere are two pairs of measurements that we will learn about in this chapter: the mean/standard deviation, and the median/IQR.\n\n4.3.1 Mean and standard deviation\nThe first pair of the summary statistics we’ll discuss consists of the mean and the standard deviation.\nThe mean of a variable \\(y\\)—denoted \\(\\bar{y}\\) and pronounced “y bar”—is calculated by summing all the values of the variable, and dividing by the total number of observations. In formula form, this is\n\\[\n\\bar{y} = \\frac{\\sum y}{n}.\n\\]\nThis is a measure of center since it estimates the “middle” of a set of numbers. It is calculated in R using the mean command.\nThroughout this chapter, we will be using the penguins data set. (If you need a reminder, look at the help file for penguins using one of the methods discussed in Chapter 2.)\nIf we want to calculate the mean body mass of our penguins (in grams), we type the following:\n\nmean(penguins$body_mass_g)\n\n[1] NA\n\n\nUnfortunately, this didn’t give us an answer. As you may recall from previous chapters, this is because we are missing data. There are several values of body mass missing in this data. We need an extra piece of code to tell R to ignore that missing data and give us the mean of the valid data.\n\nmean(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 4201.754\n\n\n(The term na.rm stands for “NA remove”.)\nWe never leave such numbers without interpretation. In a full, contextually meaningful sentence, we might say, “The mean body mass of this group of penguins is approximately 4200 grams.”\nNotice that we mentioned the penguins, placing this number in context, and we mentioned the units of measurement, grams. (Otherwise, what would this number mean? 4200 pounds? Okay, probably not, but you should always mention the units of measurement.) Also notice that we rounded the final value. A gram is a very small unit of measurement, so there is no need to report this value to many decimal places.\nIf we use inline code, we can say, “The mean body mass of this group of penguins is 4201.754386 grams.” There are ways of rounding this number as well, but it’s a bit of a hassle to do so in inline code.\nThe corresponding measure of spread is the standard deviation. Usually this is called \\(s\\) and is calculated using a much more complicated formula:\n\\[\ns = \\sqrt{\\frac{\\sum (y - \\bar{y})^2}{n - 1}}.\n\\]\nThis is a measure of spread because the \\((y - \\bar{y})\\) term measures how far away each data point is from the mean.\nIn R, this is calculated with the sd command. Again, we’ll need to add na.rm = TRUE.\n\nsd(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 801.9545\n\n\n“The standard deviation of this group of penguins is about 800 grams.”\nOr using inline code:\n“The standard deviation of this group of penguins is 801.9545357 grams.”\nThe mean and the standard deviation should always be reported together. One without the other is incomplete and potentially misleading.\nAnother related measurement is the variance, but this is nothing more than the standard deviation squared:\n\\[\ns^2 = \\frac{\\sum (y - \\bar{y})^2}{n - 1}.\n\\]\n(Compare this formula to the one for the standard deviation. Nothing has changed except for the removal of the square root.) We rarely use the variance in an introductory stats class because it’s not as interpretable as the standard deviation. The main reason for this is units. If the data units are grams, then both the mean and the standard deviation are also reported in grams. The variance has units of “grams squared”, but what does that even mean? If you need to calculate the variance in R, the command is var.\n\nvar(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 643131.1\n\n\nYou can check and see that the number above really is just 801.9545357 squared. Regarding the inline code in the previous sentence, remember, in the Quarto document, you can click inside the inline code and hit Ctrl-Enter or Cmd-Enter. In the HTML document, the number will be calculated and will magically appear.\n\n\n4.3.2 Median and IQR\nAnother choice for measuring the center and spread of a data set is the median and the IQR.\nThe median is just the middle value if the list of values is ordered. In R, it is calculated using the median command.\n\nmedian(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 4050\n\n\nThe median body mass of these penguins is 4050 grams.\nThe median value depends on whether the number of data points is an even or odd number. If it’s odd, there is a middle value in the list. Convince yourself this is true; for example, look at the numbers 1 through 7.\n\n1:7\n\n[1] 1 2 3 4 5 6 7\n\n\nThe number 4 is in the middle of the list, with three numbers to either side.\nHowever, if there are an even number of data points, there is no number right in the middle:\n\n1:8\n\n[1] 1 2 3 4 5 6 7 8\n\n\nThe “midpoint” of this list would lie between 4 and 5 with four values to either side of this line. If this is the case, we calculate the median by taking the mean of the two numbers straddling the middle. In the case of 1 though 8 above, the median would be 4.5.\nA nice shortcut “trick” for figuring out where the middle value should be is to use the formula \\((n + 1)/2\\) where n is the number of data points:\n\\[\n\\frac{n + 1}{2}\n\\]\nAs before, if n = 7, then the formula says\n\\[\n\\frac{7 + 1}{2} = 4\n\\]\nThe median is the 4th value in the list.\nIf n = 8,\nthen the formula says\n\\[\n\\frac{8 + 1}{2} = 4.5\n\\]\nThe middle of the list of numbers is between the 4th and 5th entries. The median will be the average of those two numbers.\nLet’s print out the entire body_mass_g variable, all 342 valid values (not including the missing values, of course). If we’re clever about it, we can see them in order using the sort command.\n\nsort(penguins$body_mass_g)\n\n  [1] 2700 2850 2850 2900 2900 2900 2900 2925 2975 3000 3000 3050 3050 3050 3050\n [16] 3075 3100 3150 3150 3150 3150 3175 3175 3200 3200 3200 3200 3200 3250 3250\n [31] 3250 3250 3250 3275 3300 3300 3300 3300 3300 3300 3325 3325 3325 3325 3325\n [46] 3350 3350 3350 3350 3350 3400 3400 3400 3400 3400 3400 3400 3400 3425 3425\n [61] 3450 3450 3450 3450 3450 3450 3450 3450 3475 3475 3475 3500 3500 3500 3500\n [76] 3500 3500 3500 3525 3525 3550 3550 3550 3550 3550 3550 3550 3550 3550 3575\n [91] 3600 3600 3600 3600 3600 3600 3600 3625 3650 3650 3650 3650 3650 3650 3675\n[106] 3675 3700 3700 3700 3700 3700 3700 3700 3700 3700 3700 3700 3725 3725 3725\n[121] 3750 3750 3750 3750 3750 3775 3775 3775 3775 3800 3800 3800 3800 3800 3800\n[136] 3800 3800 3800 3800 3800 3800 3825 3850 3875 3900 3900 3900 3900 3900 3900\n[151] 3900 3900 3900 3900 3950 3950 3950 3950 3950 3950 3950 3950 3950 3950 3975\n[166] 4000 4000 4000 4000 4000 4050 4050 4050 4050 4050 4050 4075 4100 4100 4100\n[181] 4100 4100 4150 4150 4150 4150 4150 4150 4200 4200 4200 4200 4200 4250 4250\n[196] 4250 4250 4250 4275 4300 4300 4300 4300 4300 4300 4300 4300 4350 4350 4375\n[211] 4400 4400 4400 4400 4400 4400 4400 4400 4450 4450 4450 4450 4450 4475 4500\n[226] 4500 4500 4550 4550 4575 4600 4600 4600 4600 4600 4625 4625 4650 4650 4650\n[241] 4650 4650 4675 4700 4700 4700 4700 4700 4700 4725 4725 4725 4750 4750 4750\n[256] 4750 4750 4775 4800 4800 4800 4850 4850 4850 4850 4875 4875 4875 4900 4900\n[271] 4925 4925 4950 4950 4975 5000 5000 5000 5000 5000 5000 5050 5050 5050 5100\n[286] 5100 5100 5150 5150 5200 5200 5200 5200 5250 5250 5250 5300 5300 5300 5300\n[301] 5350 5350 5350 5400 5400 5400 5400 5400 5450 5500 5500 5500 5500 5500 5550\n[316] 5550 5550 5550 5550 5550 5600 5600 5650 5650 5650 5700 5700 5700 5700 5700\n[331] 5750 5800 5800 5850 5850 5850 5950 5950 6000 6000 6050 6300\n\n\n\nExercise 1\nIf there are 342 penguins in this data set with body mass data, between which two values in the list above would the median lie? In other words, between what two positions in the list will be median be found? Show your work using the \\((n + 1)/2\\) trick.\nVerify that the median you find from this list is the same as the one we calculated with the median command above.\n\nPlease write up your answer here.\n\n\nCalculating the interquartile range—or IQR—requires first the calculation of the first and third quartiles, denoted Q1 and Q3. If the median is the 50% mark in the sorted data, the first and third quartiles are the 25% and the 75% marks, respectively. One way to compute these by hand is to calculate the median of the lower and upper halves of the data separately. Then again, it’s hard to know how to split the data set into halves if there are an odd number of observations. There are many different methods for computing percentiles in general, but you don’t need to worry too much about the particular implementation in R. One you have Q1 and Q3, the IQR is just\n\\[\nIQR = Q3 - Q1\n\\]\nIn R, you can get the IQR by using—are you ready for this?—the IQR command.\n\nIQR(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 1200\n\n\nThe IQR for this group of penguins is 1200 grams.\nThe IQR is a measure of spread because the distance between Q1 and Q3 measures the span of the “middle 50%” of the data.\nA general function for computing any percentile in R is the quantile function. For example, since Q1 is the 25th percentile, you can compute it as follows:\n\nQ1 &lt;- quantile(penguins$body_mass_g, 0.25, na.rm = TRUE)\nQ1\n\n 25% \n3550 \n\n\nThe 25% label is cute, but somewhat unnecessary, and it will mess up a later command, so let’s get rid of it:\n\nQ1 &lt;- unname(Q1)\nQ1\n\n[1] 3550\n\n\n\n\nExercise 2(a)\nNow you compute Q3. (Hint: what number will go in the quantile function instead of 0.25?)\n\n\n# Add code here to compute, store, and print out Q3\n\n\n\n\nExercise 2(b)\nReassign Q3 using the unname command as we did above to strip the unnecessary label.\n\n\n# Add code here that uses the unname command \n\n\n\n\nExercise 2(c)\nSubtract Q3 minus Q1 in R. (Literally, the code is just Q3 - Q1.)\nVerify that the output below matches the value of the IQR we calculated earlier.\n\n\n# Add code here to compute Q3 - Q1.\n\n\n\nThe median and the IQR should always be reported together.\nAlso, don’t mix and match. For example, it doesn’t really make sense to report the mean and the IQR. Nor should you report the median and the standard deviation. They go together in pairs: either the mean and the standard deviation together, or the median and the IQR together.\n\n\n\n4.3.3 Robust statistics\nSome statistics are more sensitive than others to features of the data. For example, outliers are data points that are far away from the bulk of the data. The mean and especially the standard deviation can change a lot when outliers are present. Also, skewness in the data frequently pulls the mean too far in the direction of the skew while simultaneously inflating the standard deviation. (We’ll learn more about skewed data later in this chapter.)\nOn the other hand, the median and IQR are “robust”, meaning that they do not change much (or at all) in the presence of outliers and they tend to be good summaries even for skewed data.\n\nExercise 3\nExplain why the median and IQR are robust. In other words, why does an outlier have little or no influence on the median and IQR?\n\nPlease write up your answer here.\n\n\n\n\n\n4.3.4 Five-number summary\nA five-number summary is the minimum, Q1, median, Q3, and maximum of a set of numbers.\nThe summary command in R gives you the five-number summary, and throws in the mean for good measure. (Note that it does not require na.rm = TRUE!)\n\nsummary(penguins$body_mass_g)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   2700    3550    4050    4202    4750    6300       2 \n\n\nYou can, of course, isolate the various pieces of this. You already know most of the commands below. (These individual commands all do require na.rm = TRUE.)\n\nmin(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 2700\n\n\n\nmedian(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 4050\n\n\n\nmax(penguins$body_mass_g, na.rm = TRUE)\n\n[1] 6300\n\n\nRemember the quantile function from earlier, where we computed Q1? We’re going to use it in a new way. This is what we did before:\nquantile(penguins$body_mass_g, 0.25, na.rm = TRUE),\nWhat about this instead?\n\nquantile(penguins$body_mass_g, na.rm = TRUE)\n\n  0%  25%  50%  75% 100% \n2700 3550 4050 4750 6300 \n\n\n\nExercise 4\nWhat is the small difference between the way quantile was used in a previous exercise versus the way it is used here? How did that change the output?\n\nPlease write up your answer here.\n\n\nAlso, don’t forget about the trick for using R commands inline. If you need to mention a statistic in the middle of a sentence, there is no need to break the sentence and display a code chunk. Be sure you’re looking at the Quarto document (not the HTML file) to note that the numbers in the next sentence are not manually entered, but are calculated on the fly:\nThere are 344 penguins in this data set and their median body mass is 4050 grams.\n\n\nExercise 5\nType a full, contextually meaningful sentence using inline R code (as above, but changing the commands) reporting the minimum and maximum body mass (in grams) in our data set.\nRemember that inline code requires a backtick immediately followed by the letter r and then a space. Then you can type your R code. The code must be followed by another backtick. You will need two pieces of inline code in your answer to report both the minimum and maximum in context.\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#graphing-one-numerical-variable",
    "href": "04-numerical_data-web.html#graphing-one-numerical-variable",
    "title": "4  Numerical data",
    "section": "4.4 Graphing one numerical variable",
    "text": "4.4 Graphing one numerical variable\nFrom the penguins data, let’s consider again the body mass in grams. This is clearly a numerical variable.\nThe single most useful display of a single numerical variable is a histogram. Here is the ggplot command to do that:\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nThe way histograms work is to create “bins”, which are ranges of numbers along the x-axis. R goes through the data and counts how many observations fall into each bin. In that way, a histogram is somewhat like a bar chart. However, a bar chart uses bars to represent distinct, discrete categories, whereas a histogram uses bars that are all next to each other to represent values along a continuous numerical range. Histograms are meant to give you–at a quick glance–a sense of the “shape” of the data.\n\n4.4.1 The shape of data\nWhat do we mean by “shape”? Generally, we look for three things:\n\nModes\n\n\nModes are peaks in the data. These are places where data tends to cluster, representing common values of the numerical variable. In the penguin data, there appears to be a big mode between about 3500 and 4000 grams. When data has one clear mode, we call the data unimodal. But data can also be bimodal, or more generally, multimodal. This often happens when the data contains multiple groups that are different from each other. In this case, we know there are three species of penguin in the data, so if those species are drastically different in their body mass, we might be looking at multimodal data. We’ll explore this question more later in the chapter. For now, it’s hard to say what’s going on because the above histogram has a lot of spiky bars popping up all over. It’s not completely obvious how many modes there might be.\n\n\nSymmetry\n\n\nIf there is one mode, we can also ask if the data is spread evenly to the left and right of that mode. If so, we call the data symmetric. No data is perfectly symmetric, but we are looking for overall balance between the areas to the left and right of the mode. When data is not symmetric, we call it skewed. Assuming that there is one big mode around 3500 or 4000, the body mass data above is skewed. There is clearly more data to the right of the mode than to the left. The right side of the histogram stretches out further than the left relative to the mode. Therefore, the body mass data is right-skewed. There is a longer “tail” to the right. If it were the opposite, it would be left-skewed. It is common for beginning students to confuse these two terms. Be aware that we are not concerned about where the mode is. We want to know which side has more data spread into a longer tail. That is the direction of the skewness.\n\n\nOutliers.\n\n\nOutliers are data points that are far from the bulk of the data. The body mass data above appears to have no outliers. We are looking for a large gap between the main “mass” of data and any lingering data points far away from that mass. There is no such large gap in the histogram above.\n\nWhenever you are asked about the “shape” of a numerical variable, be sure to comment on (1) modes, (2) symmetry, and (3) outliers.\nGenerally, the default binning for ggplot histograms is not great. This is by design. The creator of the ggplot2 package, Hadley Wickham, said the following:\n\n“In ggplot2, a very simple heuristic is used for the default number of bins: it uses 30, regardless of the data. This is perverse, and ignores all of the research on selecting good bin sizes automatically, but sends a clear message to the user that he or she needs to think about, and experiment with, the bin width. This message is reinforced with a warning that reminds the user to manually adjust the bin width.”\n\nIndeed, if you look at the output from the graphing command above, you can see that ggplot informs you that you should pick a better value for the binwidth. You can also see that the bins aren’t ideal. They are too narrow, which means that arbitrary differences between bins show up as “random” spikes all over the graph. These spikes can confuse the issue of how many modes appear in the data.\nInstead, we should aim to use bins that show the overall shape of the data and smooth it out a bit. Look back at the scale of the x-axis to assess how wide each bar should be. There’s no one correct answer. In this case, the bins ought to be a little wider. Since our x-axis goes from about 2500 to 6500, maybe we should try a binwidth of 250. And if 250 doesn’t look good, nothing prevents us from trying a different number.\nIt’s also easier to interpret the histogram when the bins’ edges line up with numbers that are easy to see in the plot. Use boundary to determine where you want the bin boundaries to fall. For example, if we set the boundary to 3500, that means that one bar will start with its left edge at 3500. This is convenient because there is a tick mark labeled there on the x-axis. The boundary number is pretty arbitrary; once one boundary is set, it determines where all the other bins will line up. With a binwidth of 250, we’d get the same graph if the boundary were set to 3000 or 3250 or 5750, or even 0. Any other multiple of 250 would give the same graph.\nWe use binwidth and boundary inside the parentheses of the geom_histogram to modify these parameters.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 250, boundary = 3500)\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nEven with the smoother look, it appears that there are multiple modes, maybe three? Do these correspond to the three species of penguin? Stay tuned.\n(Note that we are still seeing a warning, but this warning is about missing data. We can’t do anything about that, so we can safely ignore this warning.)\n\nExercise 6(a)\nHere is a histogram of the penguin bill lengths (measured in millimeters):\n\nggplot(penguins, aes(x = bill_length_mm)) +\n  geom_histogram(binwidth = 6, boundary = 30)\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nWrite a short paragraph describing the shape of the distribution of penguin bill lengths, focusing on the three key shape features (modes, symmetry, and outliers).\n\nPlease write up your answer here.\n\n\n\nExercise 6(b)\nThe last question was a trick question!\nChange the binwidth (no need to change the boundary) to something smaller to see more clearly the bimodal nature of the distribution.\n\n\n# Add code here that changes the binwidth of the last histogram to see\n# the bimodal nature of the distribution.\n\n\n\n\nExercise 7(a)\nMake a histogram of the variable flipper_length_mm. Start with a histogram where you don’t modify the binwidth or boundary. (In other words, use geom_histogram() with nothing inside the parentheses.)\n\n\n# Add code here to create a histogram of flipper length\n\n\n\n\nExercise 7(b)\nBy examining the scale on the x-axis above, repeat the command, but this time change the binwidth until you are satisfied that the bins are neither too wide nor too narrow. (You can set the boundary too, but your choice of boundary is not super important.)\n\n\n# Add code here to modify the histogram of flipper length,\n# adding binwidth and boundary\n\n\n\n\nExercise 7(c)\nWrite a short paragraph describing the shape of the distribution of penguin flipper lengths, focusing on the three key shape features (modes, symmetry, and outliers).\n\nPlease write up your answer here.\n\n\n\n\n4.4.2 Less useful plot types\nThere are several other graph types that one might see for a single numerical variable: e.g., dotplots, stem-and-leaf plots, boxplots, etc. We’re not big fans of dotplots or stem-and-leaf plots as they are just messier versions of histograms. We do like boxplots, but they are typically less informative than histograms. Boxplots are much better for comparing groups, and we’ll see them later in the chapter.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#graphing-two-numerical-variables",
    "href": "04-numerical_data-web.html#graphing-two-numerical-variables",
    "title": "4  Numerical data",
    "section": "4.5 Graphing two numerical variables",
    "text": "4.5 Graphing two numerical variables\nThe proper graph for two numerical variables is a scatterplot. We graph the response variable on the y-axis and the predictor variable on the x-axis.2\nLet’s consider a possible association between bill length and body mass. For this question, there is not really a strong preference for which variable serves as response and which variable servers as predictor. We’ll consider bill length as the response variable and body mass as the predictor.\nSince we are plotting two variables, we have two aesthetics, one on the y-axis (the response variable) and one on the x-axis (the predictor variable). Since scatterplots use points to plot each data value, the correct layer to add is geom_point().\n\nggplot(penguins, aes(y = bill_length_mm, x = body_mass_g)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe are looking for evidence of a relationship between the two variables. This will manifest as a pattern in the data. We are interested in answering the following questions:\n\nLinearity\n\n\nIs the association linear? In other words, do the data points lie roughly in a straight line pattern? The scatterplot above is a bit “cloudy” but generally moves from lower left to upper right in a straight (not curved pattern). It’s not a completely random scatter of dots.\n\n\nDirection\n\n\nIf the pattern is linear, it is a positive relationship or a negative one? Positive means that the line moves from lower left to upper right. Negative means it moves from upper left to lower right. If you recall the direction of slopes from high school algebra class, a positive association corresponds to a line with a positive slope, and similarly for a negative association. In the data above, lower values of body mass correspond to lower bill lengths, and higher values of body mass correspond to higher bill lengths. So this is a positive association.\n\n\nStrength\n\n\nIf there is a pattern, how tight is the pattern? Do the data points stay close to a straight line, or are they pretty spread out and only generally moving in one direction. A strong relationship is one that is tightly packed around a line or curve. The relationship above is not strong. We might use terms like “weak”, “moderately weak”, or “moderate”, but definitely not strong.\n\n\nOutliers\n\n\nAre there outliers? These will be points that are isolated and relatively far from the bulk of the data. There are a few points above that are borderline, but none is a particularly strong outlier, especially given how spread out the rest of the data is.\n\n\nExercise 8\nHere is a scatterplot of flipper lengths against body mass:\n\nggplot(penguins, aes(y = flipper_length_mm, x = body_mass_g)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWrite a short paragraph describing the association of penguin flipper lengths and body mass, focusing on the four key features (linearity, direction, strength, and outliers).\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#graphing-grouped-numerical-data",
    "href": "04-numerical_data-web.html#graphing-grouped-numerical-data",
    "title": "4  Numerical data",
    "section": "4.6 Graphing grouped numerical data",
    "text": "4.6 Graphing grouped numerical data\nSuppose you want to analyze one numerical variable and one categorical variable. Usually, the idea here is that the categorical variable divides up the data into groups and you are interested in understanding the numerical variable for each group separately. Another way to say this is that your numerical variable is response and your categorical variable is predictor. (It is also possible for a categorical variable to be response and a numerical variable to be predictor. This is common in so-called “classification” problems. We will not cover this possibility in this course, but it is covered in more advanced courses.)\nThis turns out to be exactly what we need in the penguins data. Throughout the above exercises, there was a concern that the penguin measurements are fundamentally different among the three different species of penguin.\nGraphically, there are two good options here. The first is a side-by-side boxplot.\n\nggplot(penguins, aes(y = body_mass_g, x = species)) +\n  geom_boxplot()\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nNotice the placement of the variables. The y-axis is body_mass_g, the numerical variable. The x-axis variable is species; the groups are placed along the x-axis. This is consistent with other graph types that place the response variable on the y-axis and the predictor variable on the x-axis.\nThe other possible graph is a stacked histogram. This uses a feature called “faceting” that creates a different plot for each group. The new ggplot command is called facet_grid. The only slightly unusual syntax you need to know is that the predictor variable has to be inside vars() as in the following code chunk:\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram() +\n  facet_grid(rows = vars(species))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nAs always, the default bins suck, so let’s change them.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 250, boundary = 3500) +\n  facet_grid(rows = vars(species))\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nNotice that we specified rows in the facet_grid function. What if we had specified columns instead?\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 250, boundary = 3500) +\n  facet_grid(cols = vars(species))\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\nExercise 9\nExplain why that last graph (which might be called a side-by-side histogram) is less effective than the earlier stacked histogram. (Hint: which variable can you line up with your eyes when the histograms are stacked vertically rather than horizontally?)\n\nPlease write up your answer here.\n\n\nThe other thing that kind of sucks is the fact that the y-axis is showing counts. That makes it harder to see the distribution of body mass among Chinstrap penguins, for example, as there are fewer of them in the data set. It would be nice to scale these using percentages.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(aes(y = after_stat(density)),\n                 binwidth = 250, boundary = 3500) +\n  facet_grid(rows = vars(species))\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nDue to some technical issues in ggplot2, these are not strictly proportions. (If you were to add up the heights of all the bars, they would not add up to 100%.) Nevertheless, the graph is still useful because it does scale the groups to put them on equal footing. In other words, it treats each group as if they all had the same sample size.\n\n\nExercise 10\nChoose a numerical variable that’s not body mass and a categorical variable that’s not species from the penguins data set. Make both a side-by-side boxplot and a stacked histogram. Discuss the resulting graphs. Comment on the association (or independence) of the two variables.\n\n\n# Add code here to create a side-by-side boxplot.\n\n\n# Add code here to create a stacked histogram.\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#publication-ready-graphics",
    "href": "04-numerical_data-web.html#publication-ready-graphics",
    "title": "4  Numerical data",
    "section": "4.7 Publication-ready graphics",
    "text": "4.7 Publication-ready graphics\nThe great thing about ggplot2 graphics is that they are already quite pretty. To take them from exploratory data analysis to the next level, there are a few things we can do to tidy them up.\nLet’s go back to the first histogram from this chapter.\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 250, boundary = 3500)\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nThe variable names of this data set are already pretty informative, but we can do a little better with labs (for labels). Observe:\n\nggplot(penguins, aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 250, boundary = 3500) +\n  labs(title = \"Distribution of body mass for adult foraging penguins near\n       Palmer Station, Antarctica\",\n       x = \"Body mass (grams)\",\n       y = \"Count\")\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nYou can also see that we took the opportunity to mention the units of measurement (grams) for our variable in the x-axis label. This is good practice.\nA quick note about formatting in R code chunks. Notice that we often put different parts of the commands on their own separate lines. The last ggplot command would still work if we did this:\n\nggplot(penguins, aes(x = body_mass_g)) + geom_histogram(binwidth = 250, boundary = 3500) + labs(title = \"Distribution of body mass for adult foraging penguins near Palmer Station, Antarctica\", x = \"Body mass (in grams)\", y = \"Count\")\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nBut it’s much harder to read. If you find that your code is “wrapping” to the next line, find some spots like commas or plus signs to break the code. Be sure to break the line after the comma or plus sign.\n\nExercise 11\nModify the following scatterplot by adding a title and labels for both the y-axis and x-axis. (Don’t forget to include units of measurement on both axes!)\n\n\n# Modify the following scatterplot by adding a title and \n# labels for both the y-axis and x-axis.\nggplot(penguins, aes(y = bill_length_mm, x = bill_depth_mm)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 12\nThe previous scatterplot looks a little funny due to some odd groupings that we suspect (as usual) might be due to multiple species being measured. Let’s use color to investigate! Once we decide to involve color, we’ll need to add a Viridis color palette to make it colorblind-friendly. This time, though, the command is scale_color_viridis_d instead of scale_fill_viridis_d. In ggplot, the “color” aesthetic is used for points in a scatterplot, as opposed to “fill” for bars in a bar chart. We’ll also use a more simple black-and-white background theme. We’ve already added the necessary code below for you.\nYour task is to make the color appear. Add a new aesthetic (so, inside the parentheses following aes) to the following code to assign color = species.\nBelow the graph, comment on what you see.\n\n\n# Modify the aesthetics to add color = species\nggplot(penguins, aes(y = bill_length_mm, x = bill_depth_mm)) +\n  geom_point() +\n  scale_color_viridis_d() +\n  theme_bw()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nPlease write up your answer here.\n\nAnother way to include a grouping variable is to use shape instead of color.\n\nggplot(penguins, aes(y = bill_length_mm, x = bill_depth_mm,\n                     shape = species)) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nThe defaults here leave a lot to be desired. It’s hard to see clusters in the data when all the shapes (circle, triangle, and square) look like similar little blobs.\nWith some advanced customization, we can get a slightly more visually distinct choice of shapes, but it may not be worth the extra work unless you are forced to print in black-and-white (say, as required by a print publication).\n\nggplot(penguins, aes(y = bill_length_mm, x = bill_depth_mm,\n                     shape = species)) +\n  geom_point() +\n  scale_shape_manual(values = c(2, 3, 20))\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nThis website has a nice description of all the available shapes and how to use them: https://blog.albertkuo.me/post/point-shape-options-in-ggplot/\nEvery part of the graph can be customized, from the color scheme to the tick marks on the axes, to the major and minor grid lines that appear on the background. We won’t go into all that, but you can look at the ggplot2 documentation online and search Google for examples if you want to dig in and figure out how to do some of that stuff. However, the default options are often (but not always) the best, so be careful that your messing around doesn’t inadvertently make the graph less clear or less appealing.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#conclusion",
    "href": "04-numerical_data-web.html#conclusion",
    "title": "4  Numerical data",
    "section": "4.8 Conclusion",
    "text": "4.8 Conclusion\nSummary statistics are simple numbers that describe and summarize data sets. Measures of center tell us where the “middle” of our numerical data lies, and measures of spread tell us how spread out our numerical data is. These measures should always be reported in pairs, for example the mean/standard deviation, or the median/IQR.\nThe ggplot2 package with its ggplot command is a very versatile tool for creating nice graphs relatively easily. For a single numerical variable, the standard graph type is a histogram. For two numerical variables, use a scatterplot. For a numerical response with a categorical predictor, use either a side-by-side boxplot or a stacked histogram.\n\n4.8.1 Preparing and submitting your assignment\n\nFrom the “Run” menu, select “Restart R and Run All Chunks”.\nDeal with any code errors that crop up. Repeat steps 1–2 until there are no more code errors.\nSpell check your document by clicking the icon with “ABC” and a check mark.\nHit the “Render” button one last time to generate the final draft of the HTML file. (If there are errors here, you may need to go back and fix broken inline code or other markdown issues.)\nProofread the HTML file carefully. If there are errors, go back and fix them, then repeat steps 1–5 again.\n\nIf you have completed this chapter as part of a statistics course, follow the directions you receive from your professor to submit your assignment.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "04-numerical_data-web.html#footnotes",
    "href": "04-numerical_data-web.html#footnotes",
    "title": "4  Numerical data",
    "section": "",
    "text": "This notation is part of a mathematical document preparation system called LaTeX, pronounced “Lay-tek” (not like the rubbery substance).↩︎\nUnless you run in certain circles with economists. For some reason, economists often switch their axes.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Numerical data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html",
    "href": "05-manipulating_data-web.html",
    "title": "5  Manipulating data",
    "section": "",
    "text": "5.1 Introduction\nThis tutorial will import some data from the web and then explore it using the amazing dplyr package, a package which is quickly becoming the de facto standard among R users for manipulating data. It’s part of the tidyverse that we’ve already used in several chapters.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#introduction",
    "href": "05-manipulating_data-web.html#introduction",
    "title": "5  Manipulating data",
    "section": "",
    "text": "5.1.1 Install new packages\nThere are no new packages used in this chapter.\n\n\n5.1.2 Download the Quarto file\nLook at either the top (Posit Cloud) or the upper right corner of the RStudio screen to make sure you are in your intro_stats project.\nThen click on the following link to download this chapter as a Quarto file (.qmd).\nhttps://vectorposse.github.io/intro_stats/chapter_downloads/05-manipulating_data.qmd\nOnce the file is downloaded, move it to your project folder in RStudio and open it there.\n\n\n5.1.3 Restart R and run all chunks\nIn RStudio, select “Restart R and Run All Chunks” from the “Run” menu.\n\n\n5.1.4 Load packages\nWe load the tidyverse package as usual, but this time it is to give us access to the dplyr package, which is loaded alongside our other tidyverse packages like ggplot2. The tidyverse also has a package called readr that will allow us to import data from an external source (in this case, a web site).\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#importing-csv-data",
    "href": "05-manipulating_data-web.html#importing-csv-data",
    "title": "5  Manipulating data",
    "section": "5.2 Importing CSV data",
    "text": "5.2 Importing CSV data\nFor most of the chapters, we use data sets that are either included in base R or included in a package that can be loaded into R. But it is useful to see how to get a data set from outside the R ecosystem. This depends a lot on the format of the data file, but a common format is a “comma-separated values” file, or CSV file. If you have a data set that is not formatted as a CSV file, it is usually pretty easy to open it in something like Google Spreadsheets or Microsoft Excel and then re-save it as a CSV file.\nThe file we’ll import is a random sample from all the commercial domestic flights that departed from Houston, Texas, in 2011.\nWe use the read_csv command to import a CSV file. In this case, we’re grabbing the file from a web page where the file is hosted. If you have a file on your computer, you can also put the file into your project directory and import it from there. Put the URL (for a web page) or the filename (for a file in your project directory) in quotes inside the read_csvcommand. We also need to assign the output to a tibble, so we’ve called it hf for “Houston flights”.\n\nhf &lt;- read_csv(\"https://vectorposse.github.io/intro_stats/data/hf.csv\")\n\nRows: 22758 Columns: 21\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (5): UniqueCarrier, TailNum, Origin, Dest, CancellationCode\ndbl (16): Year, Month, DayofMonth, DayOfWeek, DepTime, ArrTime, FlightNum, A...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nhf\n\n\n  \n\n\n\n\nglimpse(hf)\n\nRows: 22,758\nColumns: 21\n$ Year              &lt;dbl&gt; 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011…\n$ Month             &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ DayofMonth        &lt;dbl&gt; 12, 17, 24, 9, 18, 22, 11, 14, 26, 14, 18, 20, 3, 12…\n$ DayOfWeek         &lt;dbl&gt; 3, 1, 1, 7, 2, 6, 2, 5, 3, 5, 2, 4, 1, 3, 6, 4, 1, 3…\n$ DepTime           &lt;dbl&gt; 1419, 1530, 1356, 714, 721, 717, 1953, 2119, 2009, 1…\n$ ArrTime           &lt;dbl&gt; 1515, 1634, 1513, 829, 827, 829, 2051, 2229, 2103, 1…\n$ UniqueCarrier     &lt;chr&gt; \"AA\", \"AA\", \"AA\", \"AA\", \"AA\", \"AA\", \"AA\", \"AA\", \"AA\"…\n$ FlightNum         &lt;dbl&gt; 428, 428, 428, 460, 460, 460, 533, 533, 533, 1121, 1…\n$ TailNum           &lt;chr&gt; \"N577AA\", \"N518AA\", \"N531AA\", \"N586AA\", \"N558AA\", \"N…\n$ ActualElapsedTime &lt;dbl&gt; 56, 64, 77, 75, 66, 72, 58, 70, 54, 65, 135, 144, 64…\n$ AirTime           &lt;dbl&gt; 41, 48, 43, 51, 46, 47, 44, 45, 39, 47, 114, 111, 46…\n$ ArrDelay          &lt;dbl&gt; 5, 84, 3, -6, -8, -6, -29, 69, -17, -11, 39, -1, -2,…\n$ DepDelay          &lt;dbl&gt; 19, 90, -4, -6, 1, -3, -12, 74, 4, -1, 44, -5, -1, 1…\n$ Origin            &lt;chr&gt; \"IAH\", \"IAH\", \"IAH\", \"IAH\", \"IAH\", \"IAH\", \"IAH\", \"IA…\n$ Dest              &lt;chr&gt; \"DFW\", \"DFW\", \"DFW\", \"DFW\", \"DFW\", \"DFW\", \"DFW\", \"DF…\n$ Distance          &lt;dbl&gt; 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 96…\n$ TaxiIn            &lt;dbl&gt; 4, 8, 6, 11, 7, 18, 3, 5, 9, 8, 7, 20, 5, 8, 8, 7, 4…\n$ TaxiOut           &lt;dbl&gt; 11, 8, 28, 13, 13, 7, 11, 20, 6, 10, 14, 13, 13, 10,…\n$ Cancelled         &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ CancellationCode  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ Diverted          &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n\n\nThe one disadvantage of a file imported from the internet or your computer is that it does not come with a help file. (Only packages in R have help files.) Hopefully you have access to some kind of information about the data you’re importing. In this case, we get lucky because the full Houston flights data set happens to be available in a package called hflights.\n\nExercise 1\nClick this link to view a copy of the documentation for the full Houston flights data. Read the webpage so you know what all the variables mean. Report below how many flights are in the original hflights data. What fraction of the original data has been sampled in the CSV file we imported above?\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#introduction-to-dplyr",
    "href": "05-manipulating_data-web.html#introduction-to-dplyr",
    "title": "5  Manipulating data",
    "section": "5.3 Introduction to dplyr",
    "text": "5.3 Introduction to dplyr\nThe dplyr package (pronounced “dee-ply-er”) contains tools for manipulating the rows and columns of tibbles. The key to using dplyr is to familiarize yourself with the “key verbs”:\n\nselect (and rename)\nfilter (and slice)\narrange\nmutate (and transmute)\nsummarise (with group_by)\n\nWe’ll consider these one by one. We won’t have time to cover every aspect of these functions. More information appears in the help files, as well as this very helpful “cheat sheet”: https://rstudio.github.io/cheatsheets/html/data-transformation.html",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#select",
    "href": "05-manipulating_data-web.html#select",
    "title": "5  Manipulating data",
    "section": "5.4 select",
    "text": "5.4 select\nThe select verb is very easy. It just selects some subset of variables (the columns of your data set).\nThe select command from the dplyr package illustrates one of the common issues R users face. Because the word “select” is pretty common, and selecting things is a common task, there are multiple packages that have a function called select. Depending on the order in which packages were loaded, R might get confused as to which version of select you want and try to apply the wrong one. One way to get the correct version is to specify the package in the syntax. Instead of typing select, we can type dplyr::select to ensure we get the version from the dplyr package. We’ll do this in all future uses of the select function. (The other functions in this chapter don’t cause us trouble because we don’t use any other packages whose functions conflict like this.)\nSuppose all we wanted to see was the carrier, origin, and destination. The command to do this appears in the next code chunk. (Note that we’re only going to print the first 100 rows. It takes a lot of memory to keep printing tibbles that have 22,758 rows!)\n\nhf_select &lt;- dplyr::select(hf, UniqueCarrier, Origin, Dest)\nhead(hf_select, n = 100)\n\n\n  \n\n\n\nA brief but important aside here: there is nothing special about the variable name hf_select. We could have typed\nbeef_gravy &lt;- dplyr::select(hf, UniqueCarrier, Origin, Dest)\nand it would work just as well. Generally speaking, though, you want to give variables a name that reflects the intent of your analysis.\nAlso, it is important to assign the result to a variable. If we had just typed\ndplyr::select(hf, UniqueCarrier, Origin, Dest)\nthe result would print to the screen, but it wouldn’t be stored anywhere for future us.\nAlso, it is important to assign the result to a new variable. If we had typed\nhf &lt;- dplyr::select(hf, UniqueCarrier, Origin, Dest)\nthis would have overwritten the original tibble hf with this new version with only three variables. We want to preserve hf because we want to do other things with the entire data set later.\nThe take-home message here is this: Major modifications to your data should generally be given a new variable name. There are caveats here, though. Every time you create a new tibble, you also fill up more memory with your creation. So if you don’t need the old version of a tibble anymore, you are safe to overwrite the old version with something new and continue working with that newer modification.\nOkay, back to the select function. The first argument of select is the tibble. After that, just list all the names of the variables you want to select.\nIf you don’t like the names of the variables, you can change them as part of the select process. For example,\n\nhf_select &lt;- dplyr::select(hf,\n                           carrier = UniqueCarrier,\n                           origin = Origin,\n                           dest = Dest)\nhead(hf_select, n = 100)\n\n\n  \n\n\n\n(Note here that we are overwriting hf_select which had been defined slightly differently before. However, these two versions of hf_select are basically the same object, so no need to keep the older version around just taking up space unnecessarily.)\nThere are a few notational shortcuts. For example, try to figure out what the following commands are doing:\n\nhf_select2 &lt;- dplyr::select(hf, DayOfWeek:UniqueCarrier)\nhead(hf_select2, n = 100)\n\n\n  \n\n\n\n\nhf_select3 &lt;- dplyr::select(hf, starts_with(\"Taxi\"))\nhead(hf_select3, n = 100)\n\n\n  \n\n\n\n\nExercise 2\nWhat is contained in the new tibbles hf_select2 and hf_select3? In other words, what does the colon (:) appear to do and what does starts_with appear to do in the select function?\n\nPlease write up your answer here.\n\n\nThe cheat sheet shows a lot more of these “helper functions” if you’re interested.\nThe other command that’s related to select is rename. The only difference is that select will throw away any columns you don’t select (which is what you want and expect, typically), whereas rename will keep all the columns, but rename those you designate.\n\n\nExercise 3\nPutting a minus sign in front of a variable name in the select command will remove the variable. Create a tibble called hf_select4 that removes Year, DayofMonth, DayOfWeek, FlightNum, and Diverted. (Be careful with the unusual—and inconsistent!—capitalization in those variable names.) In the second part of the code chunk below, type head(hf_select4, n = 100) so that the first 100 rows of the tibble print to the screen (just like in all the above examples).\n\n\n# Add code here to define hf_select4.\n# Add code here to print the first 100 rows of hf_select4.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#filter",
    "href": "05-manipulating_data-web.html#filter",
    "title": "5  Manipulating data",
    "section": "5.5 filter",
    "text": "5.5 filter\nThe filter verb works a lot like select, but for rows instead of columns.\nFor example, let’s say we only want to see Delta flights. We use filter. (We can print all the rows here because the resulting tibble is much smaller!)\n\nhf_filter &lt;- filter(hf, UniqueCarrier == \"DL\")\nhf_filter\n\n\n  \n\n\n\nIn the printout of the tibble above, if you can’t see the UniqueCarrier column, click the black arrow on the right to scroll through the columns until you can see it. You can click “Next” at the bottom to scroll through the rows.\n\nExercise 4\nHow many rows did we get in the hf_filter tibble? What do you notice about the UniqueCarrier of all those rows?\n\nPlease write up your answer here.\n\n\nJust like select, the first argument of filter is the name of the tibble. Following that, you must specify some condition. Only rows meeting that condition will be included in the output.\nOne thing that is unusual here is the double equal sign (UniqueCarrier == \"DL\"). This won’t be a mystery to people with programming experience, but it tends to be a sticking point for the rest of us. A single equals sign represents assignment. If I type x = 3, what I mean is, “Take the letter x and assign it the value 3.” In R, we would also write x &lt;- 3 to mean the same thing. The first line of the code chunk below assigns x to be 3. Therefore, the following line that just says x creates the output “3”.\n\nx = 3\nx\n\n[1] 3\n\n\nOn the other hand, x == 3 means something completely different. This is a logical statement that is either true or false. Either x is 3, in which case we get TRUE or x is not 3, and we get FALSE.\n\nx == 3\n\n[1] TRUE\n\n\n(It’s true because we just assigned x to be 3 in the previous code chunk!)\nIn the above filter command, we are saying, “Give us the rows where the value of UniqueCarrier is \"DL\", or, in other words, where the statement UniqueCarrier == \"DL\" is true.\nAs another example, suppose we wanted to find out all flights that leave before 6:00 a.m. Due to the interesting way that times are stored in this data, we can do something like the following:\n\nhf_filter2 &lt;- filter(hf, DepTime &lt; 600)\nhf_filter2\n\n\n  \n\n\n\n\n\nExercise 5\nLook at the help file for hflights again (linked in Exercise 1). Why do we have to use the number 600 in the command above? (Read the description of the DepTime variable.)\n\nPlease write up your answer here.\n\n\nIf we need two or more conditions, we use & for “and” and | for “or”. The following will give us only the Delta flights that departed before 6:00 a.m.\n\nhf_filter3 &lt;- filter(hf, UniqueCarrier == \"DL\" & DepTime &lt; 600)\nhf_filter3\n\n\n  \n\n\n\nAgain, check the cheat sheet for more complicated condition-checking if needed.\n\n\nExercise 6(a)\nThe symbol != means “not equal to” in R. Use the filter command to create a tibble called hf_filter4 that finds all flights except those flying into Salt Lake City (“SLC”). As before, print the output to the screen.\n\n\n# Add code here to define hf_filter4.\n# Add code here to print hf_filter4.\n\n\n\n\nExercise 6(b)\nBased on the output of the previous part, how many flights were there flying into SLC? (In other words, how many rows were removed from the original hf tibble to produce hf_filter4?)\n\nPlease write up your answer here.\n\n\nThe slice command is related, but fairly useless in practice. It will allow you to extract rows by position. So slice(hf, 1:10) will give you the first 10 rows. As a general rule, the information available in a tibble should never depend on the order in which the rows appear. Therefore, no function you run should make any assumptions about the ordering of your data. The only reason one might want to think about the order of data is for convenience in presenting that data visually for someone to inspect. And that brings us to…",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#arrange",
    "href": "05-manipulating_data-web.html#arrange",
    "title": "5  Manipulating data",
    "section": "5.6 arrange",
    "text": "5.6 arrange\nThis just re-orders the rows, sorting on the values of one or more specified columns. As we mentioned before, in most data analyses you work with summaries of the data that do not depend on the order of the rows, so this is not quite as interesting as some of the other verbs. In fact, since the re-ordering is usually for the visual benefit of the reader, there is often no need to store the output in a new variable. We’ll just print the output to the screen.\n\narrange(hf, ActualElapsedTime)\n\n\n  \n\n\n\nAgain, because it will start getting costly to print all these rows, we should just print some of the rows.\n\nhead(arrange(hf, ActualElapsedTime), n = 100)\n\n\n  \n\n\n\nScroll over to the ActualElapsedTime variable in the output above (using the black right arrow) to see that these are now sorted in ascending order.\n\nExercise 7\nHow long is the shortest actual elapsed time? Why is this flight so short? (Hint: look at the destination.) Which airline flies that route? You may have to use your best friend Google to look up airport and airline codes.\n\nPlease write up your answer here.\n\n\nIf you want descending order, do this:\n\nhead(arrange(hf, desc(ActualElapsedTime)), n = 100)\n\n\n  \n\n\n\n\n\nExercise 8\nHow long is the longest actual elapsed time? Why is this flight so long? Which airline flies that route? Again, you may have to use your best friend Google to look up airport and airline codes.\n\nPlease write up your answer here.\n\n\n\nExercise 9(a)\nYou can sort by multiple columns. The first column listed will be the first in the sort order, and then within each level of that first variable, the next column will be sorted, etc. Print a tibble that sorts first by destination (Dest) and then by arrival time (ArrTime), both in the default ascending order.\n\n\n# Add code here to sort hf first by Dest and then by ArrTime.\n\n\n\n\nExercise 9(b)\nBased on the output of the previous part, what is the first airport code alphabetically and to what city does it correspond? (Use Google if you need to link the airport code to a city name.) At what time did the earliest flight to that city arrive?\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#mutate",
    "href": "05-manipulating_data-web.html#mutate",
    "title": "5  Manipulating data",
    "section": "5.7 mutate",
    "text": "5.7 mutate\nFrequently, we want to create new variables that combine information from one or more existing variables. We use mutate for this. For example, suppose we wanted to find the total time of the flight. We might do this by adding up the minutes from several variables: TaxiOut, AirTime, and TaxiIn, and assigning that sum to a new variable called total. Scroll all the way to the right in the output below (using the black right arrow) to see the new total variable.\n\nhf_mutate &lt;- mutate(hf, total = TaxiOut + AirTime + TaxiIn)\nhead(hf_mutate, n = 100)\n\n\n  \n\n\n\nAs it turns out, that was wasted effort because that variable already exists in ActualElapsedTime. The all.equal command below checks that both specified columns contain the exact same values.\n\nall.equal(hf_mutate$total, hf$ActualElapsedTime)\n\n[1] TRUE\n\n\nPerhaps we want a variable that just classifies a flight as arriving late or not. Scroll all the way to the right in the output below to see the new late variable.\n\nhf_mutate2 &lt;- mutate(hf, late = (ArrDelay &gt; 0))\nhead(hf_mutate2, n = 100)\n\n\n  \n\n\n\nThis one is a little tricky. Keep in mind that ArrDelay &gt; 0 is a logical condition that is either true or false, so that truth value is what is recorded in the late variable. If the arrival delay is a positive number of minutes, the flight is considered “late”, and if the arrival delay is zero or negative, it’s not late.\nIf we would rather see more descriptive words than TRUE or FALSE, we have to do something even more tricky. Look at the late variable in the output below.\n\nhf_mutate3 &lt;- mutate(hf,\n                     late = as_factor(ifelse(ArrDelay &gt; 0, \n                                             \"Late\", \"On time\")))\nhead(hf_mutate3, n = 100)\n\n\n  \n\n\n\nThe as_factor command tells R that late should be a categorical variable. Without it, the variable would be a “character” variable, meaning a list of character strings. It won’t matter for us here, but in any future analysis, you want categorical data to be treated as such by R.\nThe main focus here is on the ifelse construction. The ifelse function takes a condition as its first argument. If the condition is true, it returns the value in the second slot, and if it’s false (the “else” part of if/else), it returns the value in the third slot. In other words, if ArrDelay &gt; 0, this means the flight is late, so the new late variable should say “Late”; whereas, if ArrDelay is not greater than zero (so either zero or possibly negative if the flight arrived early), then the new variable should say “On Time”.\nHaving said that, I would generally recommend that you leave these kinds of variables as logical types. It’s much easier to summarize such variables in R, namely because R treats TRUE as 1 and FALSE as 0, allowing us to do things like this:\n\nmean(hf_mutate2$late, na.rm = TRUE)\n\n[1] 0.4761522\n\n\nThis gives us the proportion of late flights.\nNote that we needed na.rm as you’ve seen in previous chapter. For example, look at the 93rd row of the tibble:\n\nslice(hf_mutate2, 93)\n\n\n  \n\n\n\nNotice that all the times are missing. There are a bunch of rows like this. Since there is not always an arrival delay listed, the ArrDelay variable doesn’t always have a value, and if ArrDelay is NA, the late variable will be too. So if we try to calculate the mean with just the mean command, this happens:\n\nmean(hf_mutate2$late)\n\n[1] NA\n\n\n\nExercise 10\nWhy does taking the mean of a bunch of zeros and ones give us the proportion of ones? (Think about the formula for the mean. What happens when we take the sum of all the zeros and ones, and what happens when we divide by the total?)\n\nPlease write up your answer here.\n\n\n\nExercise 11\nCreate a new tibble called hf_mutate4 that uses the mutate command to create a new variable called dist_k which measures the flight distance in kilometers instead of miles. (Hint: to get from miles to kilometers, multiply the distance by 1.60934.) Print the first 100 rows of the output to the screen.\n\n\n# Add code here to define hf_mutate4.\n# Add code here to print the first 100 rows of hf_mutate4.\n\n\n\nA related verb is transmute. The only difference between mutate and transmute is that mutate creates the new column(s) and keeps all the old ones too, whereas transmute will throw away all the columns except the newly created ones. This is not something that you generally want to do, but there are exceptions. For example, if we were preparing a report and we needed only to talk about flights being late or not, it would do no harm (and would save some memory) to throw away everything except the late variable.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#summarise-with-group_by",
    "href": "05-manipulating_data-web.html#summarise-with-group_by",
    "title": "5  Manipulating data",
    "section": "5.8 summarise (with group_by)",
    "text": "5.8 summarise (with group_by)\nFirst, before you mention that summarise is spelled wrong…well, the author of the dplyr package is named Hadley Wickham (same author as the ggplot2 package) and he is from New Zealand. So that’s the way he spells it. He was nice enough to include the summarize function as an alias if you need to use it ’cause this is ’Murica!\nThe summarise function, by itself, is kind of boring, and doesn’t do anything that couldn’t be done more easily with base R functions.\n\nsummarise(hf, mean(Distance))\n\n\n  \n\n\n\n\nmean(hf$Distance)\n\n[1] 790.5861\n\n\nWhere summarise shines is in combination with group_by. For example, let’s suppose that we want to see average flight distances, but broken down by airline. We can do the following:\n\nhf_summ_grouped &lt;- group_by(hf, UniqueCarrier)\nhf_summ &lt;- summarise(hf_summ_grouped, mean(Distance))\nhf_summ\n\n\n  \n\n\n\n\n5.8.1 Piping\nThis is a good spot to introduce a time-saving and helpful device called “piping”, denoted by the symbol |&gt;. We’ve seen this weird combination of symbols in past chapters, but we haven’t really explained what they do.\nPiping always looks more complicated than it really is. The technical definition is that\nx |&gt; f(y)\nis equivalent to\nf(x, y).\nAs a simple example, we could add two numbers like this:\n\nsum(2, 3)\n\n[1] 5\n\n\nOr using the pipe, we could do it like this:\n\n2 |&gt; sum(3)\n\n[1] 5\n\n\nAll this is really saying is that the pipe takes the thing on its left, and plugs it into the first slot of the function on its right. So why do we care?\nLet’s revisit the combination group_by/summarise example above. There are two ways to do this without pipes, and both are a little ugly. One way is above, where you have to keep reassigning the output to new variables (in the case above, to hf_summ_grouped and then hf_summ). The other way is to nest the functions:\n\nsummarise(group_by(hf, UniqueCarrier), mean(Distance))\n\n\n  \n\n\n\nThis requires a lot of brain power to parse. In part, this is because the function is inside-out: first you group hf by UniqueCarrier, and then the result of that is summarized. Here’s how the pipe fixes it:\n\nhf |&gt;\n  group_by(UniqueCarrier) |&gt;\n  summarise(mean(Distance))\n\n\n  \n\n\n\nLook at the group_by line. The group_by function would normally take two arguments: the tibble, and then the grouping variable. But it appears to have only one argument. Now look at the previous line. The pipe says to insert whatever is on its left (hf) into the first slot of the function on its right (group_by). So the net effect is still to evaluate the function group_by(hf, UniqueCarrier).\nNow look at the summarise line. Again, summarise is a function of two inputs, but all we see is the part that finds the mean. The pipe at the end of the previous line tells the summarise function to insert the stuff already computed (the grouped tibble returned by group_by(hf, UniqueCarrier)) into the first slot of the summarise function.\nPiping takes a little getting used to, but once you’re good at it, you’ll never go back. It’s just makes more sense semantically. When we read the above set of commands, we see a set of instructions in chronological order:\n\nStart with the tibble hf.\nNext, group by the carrier.\nNext, summarize each group using the mean distance.\n\nNow we can assign the result of all that to the new variable hf_summ:\n\nhf_summ &lt;- hf |&gt;\n  group_by(UniqueCarrier) |&gt;\n  summarise(mean(Distance))\nhf_summ\n\n\n  \n\n\n\nSome people even take this one step further. The result of all the above is assigned to a new variable hf_summ that currently appears as the first command (hf_summ &lt;- ...) But you could write this as\n\nhf |&gt;\n  group_by(UniqueCarrier) |&gt;\n  summarise(mean(Distance)) -&gt; hf_summ\n\nNow it says the following:\n\nStart with the tibble hf.\nNext, group by the carrier.\nNext, summarize each group using the mean distance.\nFinally, assign the result to a new variable called hf_summ.\n\n(As we’ve seen in a previous chapter, the arrow operator for assignment works both directions!)\nLet’s try some counting. This one is common enough that dplyr doesn’t even make us use group_by and summarise. We can just use the command count. What if we wanted to know how many flights correspond to each carrier?\n\nhf_summ2 &lt;- hf |&gt;\n  count(UniqueCarrier)\nhf_summ2\n\n\n  \n\n\n\nAlso note that we can give summary columns a new name if we wish. In hf_summ, we didn’t give the new column an explicit name, so it showed up in our tibble as a column called mean(Distance). If we want to change it, we can do this:\n\nhf_summ &lt;- hf |&gt;\n  group_by(UniqueCarrier) |&gt;\n  summarise(mean_dist = mean(Distance))\nhf_summ\n\n\n  \n\n\n\nLook at the earlier version of hf_summ and compare it to the one above. Make sure you see that the name of the second column changed.\nThe new count column of hf_summ2 is just called n. That’s okay, but if we insist on giving it a more user-friendly name, we can do so as follows:\n\nhf_summ2 &lt;- hf |&gt;\n  count(UniqueCarrier, name = \"total_count\")\nhf_summ2\n\n\n  \n\n\n\nThis is a little different because it requires us to use a name argument and put the new name in quotes.\n\nExercise 12(a)\nCreate a tibble called hf_summ3 that lists the total count of flights for each day of the week. Be sure to use the pipe as above. Print the output to the screen. (You don’t need to give the count column a new name.)\n\n\n# Add code here to define hf_summ3.\n# Add code here to print hf_summ3.\n\n\n\n\nExercise 12(b)\nAccording to the output in the previous part, what day of the week had the fewest flights? (Assume 1 = Monday.)\n\nPlease write up your answer here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#putting-it-all-together",
    "href": "05-manipulating_data-web.html#putting-it-all-together",
    "title": "5  Manipulating data",
    "section": "5.9 Putting it all together",
    "text": "5.9 Putting it all together\nOften we need more than one of these verbs. In many data analyses, we need to do a sequence of operations to get at the answer we seek. This is most easily accomplished using a more complicated sequence of pipes.\nHere’s an example of multi-step piping. Let’s say that we only care about Delta flights, and even then, we only want to know about the month of the flight and the departure delay. From there, we wish to group by month so we can find the maximum departure delay by month. Here is a solution, piping hot and ready to go. [groan]\n\nhf_grand_finale &lt;- hf |&gt;\n  filter(UniqueCarrier == \"DL\") |&gt;\n  dplyr::select(Month, DepDelay) |&gt;\n  group_by(Month) |&gt;\n  summarise(max_delay = max(DepDelay, na.rm = TRUE))\nhf_grand_finale\n\n\n  \n\n\n\nGo through each line of code carefully and translate it into English:\n\nWe define a variable called hf_grand_finale that starts with the original hf data.\nWe filter this data so that only Delta flights will be analyzed.\nWe select the variables Month and DepDelay, throwing away all other variables that are not of interest to us. (Don’t forget to use the dplyr::select syntax to make sure we get the right function!)\nWe group_by month so that the results will be displayed by month.\nWe summarise each month by listing the maximum value of DepDelay that appears within each month.\nWe print the result to the screen.\n\nNotice in the summarise line, we again took advantage of dplyr’s ability to rename any variable along the way, assigning our computation to the new variable max_delay. Also note the need for na.rm = TRUE so that the max command ignores any missing values.\nA minor simplification results from the realization that summarise must throw away any variables it doesn’t need. (Think about why for a second: what would summarise do with, say, ArrTime if we’ve only asked it to calculate the maximum value of DepDelay for each month?) So you could write this instead, removing the select clause:\n\nhf_grand_finale &lt;- hf |&gt;\n  filter(UniqueCarrier == \"DL\") |&gt;\n  group_by(Month) |&gt;\n  summarise(max_delay = max(DepDelay, na.rm = TRUE))\nhf_grand_finale\n\n\n  \n\n\n\nCheck that you get the same result. With massive data sets, it’s possible that the selection and sequence of these verbs matter, but you don’t see an appreciable difference here, even with 22758 rows. (There are ways of benchmarking performance in R, but that is a more advanced topic.)\n\nExercise 13\nSummarize in your own words what information is contained in the hf_grand_finale tibble. In other words, what are the numbers in the max_delay column telling us? Be specific!\n\nPlease write up your answer here.\n\nThe remaining exercises are probably the most challenging you’ve seen so far in the course. Take each slowly. Read the instructions carefully. Go back through the chapter and identify which “verb” needs to be used for each part of the task. Examine the sample code in those sections carefully to make sure you get the syntax right. Create a sequence of “pipes” to do each task, one-by-one. Copy and paste pieces of code from earlier and make minor changes to adapt the code to the given task.\n\n\nExercise 14\nCreate a tibble named hf_ex14 that counts the flights to LAX grouped by day of the week. (Hint: you need to filter to get flights to LAX. Then you’ll need to count using DayOfWeek as a grouping variable. Because you’re using count, you don’t need group_by or summarise.) Print the output to the screen.\n\n\n# Add code here to count the flights to LAX\n# grouped by day of the week.\n# Print hf_ex14 to the screen.\n\n\n\n\nExercise 15\nCreate a tibble named hf_ex15 that finds the median distance flight for each airline. Sort the resulting tibble from highest distance to lowest. (Hint: You’ll need to group_by carrier and summarise using the median function. Finally, you’ll need to arrange the result according to the median distance variable that you just created.) Print the output to the screen.\n\n\n# Add code here to find the median distance by airline.\n# Print hf_ex15 to the screen.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "05-manipulating_data-web.html#conclusion",
    "href": "05-manipulating_data-web.html#conclusion",
    "title": "5  Manipulating data",
    "section": "5.10 Conclusion",
    "text": "5.10 Conclusion\nRaw data often doesn’t come in the right form for us to run our analyses. The dplyr verbs are powerful tools for manipulating tibbles until they are in the right form.\n\n5.10.1 Preparing and submitting your assignment\n\nFrom the “Run” menu, select “Restart R and Run All Chunks”.\nDeal with any code errors that crop up. Repeat steps 1–2 until there are no more code errors.\nSpell check your document by clicking the icon with “ABC” and a check mark.\nHit the “Render” button one last time to generate the final draft of the HTML file. (If there are errors here, you may need to go back and fix broken inline code or other markdown issues.)\nProofread the HTML file carefully. If there are errors, go back and fix them, then repeat steps 1–5 again.\n\nIf you have completed this chapter as part of a statistics course, follow the directions you receive from your professor to submit your assignment.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipulating data</span>"
    ]
  },
  {
    "objectID": "Rubric.html",
    "href": "Rubric.html",
    "title": "Appendix A — Rubric for inference",
    "section": "",
    "text": "Exploratory data analysis\n2.0\nThis is the R Markdown outline for running inference, both a hypothesis test and a confidence interval.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Rubric.html#exploratory-data-analysis",
    "href": "Rubric.html#exploratory-data-analysis",
    "title": "Appendix A — Rubric for inference",
    "section": "",
    "text": "Use data documentation (help files, code books, Google, etc.) to determine as much as possible about the data provenance and structure.\n\nPlease write up your answer here\n\n# Add code here to print the data\n\n\n# Add code here to glimpse the variables\n\n\n\n\nPrepare the data for analysis. [Not always necessary.]\n\n\n# Add code here to prepare the data for analysis.\n\n\n\n\nMake tables or plots to explore the data visually.\n\n\n# Add code here to make tables or plots.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Rubric.html#hypotheses",
    "href": "Rubric.html#hypotheses",
    "title": "Appendix A — Rubric for inference",
    "section": "Hypotheses",
    "text": "Hypotheses\n\nIdentify the sample (or samples) and a reasonable population (or populations) of interest.\n\nPlease write up your answer here.\n\n\n\nExpress the null and alternative hypotheses as contextually meaningful full sentences.\n\n\\(H_{0}:\\) Null hypothesis goes here.\n\\(H_{A}:\\) Alternative hypothesis goes here.\n\n\n\nExpress the null and alternative hypotheses in symbols (when possible).\n\n\\(H_{0}: math\\)\n\\(H_{A}: math\\)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Rubric.html#model",
    "href": "Rubric.html#model",
    "title": "Appendix A — Rubric for inference",
    "section": "Model",
    "text": "Model\n\nIdentify the sampling distribution model.\n\nPlease write up your answer here.\n\n\n\nCheck the relevant conditions to ensure that model assumptions are met.\n\nPlease write up your answer here. (Some conditions may require R code as well.)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Rubric.html#mechanics",
    "href": "Rubric.html#mechanics",
    "title": "Appendix A — Rubric for inference",
    "section": "Mechanics",
    "text": "Mechanics\n\nCompute the test statistic.\n\n\n# Add code here to compute the test statistic.\n\n\n\n\nReport the test statistic in context (when possible).\n\nPlease write up your answer here.\n\n\n\nPlot the null distribution.\n\n\n# IF CONDUCTING A SIMULATION...\nset.seed(1)\n# Add code here to simulate the null distribution.\n\n\n# Add code here to plot the null distribution.\n\n\n\n\nCalculate the P-value.\n\n\n# Add code here to calculate the P-value.\n\n\n\n\nInterpret the P-value as a probability given the null.\n\nPlease write up your answer here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Rubric.html#conclusion",
    "href": "Rubric.html#conclusion",
    "title": "Appendix A — Rubric for inference",
    "section": "Conclusion",
    "text": "Conclusion\n\nState the statistical conclusion.\n\nPlease write up your answer here.\n\n\n\nState (but do not overstate) a contextually meaningful conclusion.\n\nPlease write up your answer here.\n\n\n\nExpress reservations or uncertainty about the generalizability of the conclusion.\n\nPlease write up your answer here.\n\n\n\nIdentify the possibility of either a Type I or Type II error and state what making such an error means in the context of the hypotheses.\n\nPlease write up your answer here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Rubric.html#confidence-interval",
    "href": "Rubric.html#confidence-interval",
    "title": "Appendix A — Rubric for inference",
    "section": "Confidence interval",
    "text": "Confidence interval\n\nCheck the relevant conditions to ensure that model assumptions are met.\n\nPlease write up your answer here. (Some conditions may require R code as well.)\n\n\n\nCalculate and graph the confidence interval.\n\n\n# Add code here to calculate the confidence interval.\n\n\n# Add code here to graph the confidence interval.\n\n\n\n\nState (but do not overstate) a contextually meaningful interpretation.\n\nPlease write up your answer here.\n\n\n\nIf running a two-sided test, explain how the confidence interval reinforces the conclusion of the hypothesis test. [Not always applicable.]\n\nPlease write up your answer here.\n\n\n\nWhen comparing two groups, comment on the effect size and the practical significance of the result. [Not always applicable.]\n\nPlease write up your answer here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Rubric for inference</span>"
    ]
  },
  {
    "objectID": "Concordance.html",
    "href": "Concordance.html",
    "title": "Appendix B — Concordance with Introduction to Modern Statistics (IMS)",
    "section": "",
    "text": "This book is meant to be somewhat aligned pedagogically with part of the book Introduction to Modern Statistics (IMS) by Mine Çetinkaya-Rundel and Johanna Hardin. But it’s not a perfect, one-to-one match. The table below shows the concordance between the two books with some notes that explain when one book does something different from the other.\n\n\n\n\n\n\n\n\nThis book\nIMS\nNotes\n\n\n\n\nCh. 1\n\nThis book contains a specific introduction to R and RStudio with some basic statistical vocabulary.\n\n\n\nCh. 1\nIMS introduces a lot of vocabulary. This book introduces most of that same vocabulary, but across multiple chapters.\n\n\nCh. 2\n\nThis book contains a specific introduction to R Markdown.\n\n\n\nCh. 2\nIMS discusses study design and sampling. Some of that information is scattered across multiple chapters of this book, but not all of it. (For example, this book doesn’t get into stratified or cluster sampling.)\n\n\n\nCh. 3\nIMS has “Applications” chapters at the end of each section. In this book, the applications are woven into each chapter.\n\n\nCh. 3\nCh. 4\nCategorical data.\n\n\nCh. 4\nCh. 5\nNumerical data.\n\n\nCh. 5\n\nThis book has a dedicated chapter on manipulating data using dplyr.\n\n\n\nCh. 6\nApplications.\n\n\nCh. 6\nCh. 7\nCorrelation.\n\n\nCh. 7\nCh. 7\nSimple linear regression.\n\n\n\nCh. 8\nMultiple regression—not covered in this book.\n\n\n\nCh. 9\nLogistic regression—not covered in this book.\n\n\n\nCh. 10\nApplications.\n\n\nCh. 8\nCh. 11\nIntroduction to randomization, Part 1—This book takes four chapters to cover the material that IMS covers in one chapter.\n\n\nCh. 9\nCh. 11\nIntroduction to randomization, Part 2.\n\n\nCh. 10\nCh. 11\nHypothesis testing with randomization, Part 1.\n\n\nCh. 11\nCh. 11\nHypothesis testing with randomization, Part 2.\n\n\nCh. 12\nCh. 12\nConfidence intervals.\n\n\nCh. 13\nCh. 13\nNormal models—This book takes two chapters to cover the material that IMS covers in one chapter.\n\n\nCh. 14\nCh. 13\nSampling distribution models.\n\n\n\nCh. 14\nIMS has a chapter on decision errors that was covered in this book back in Ch. 10. It also covers the concept of power, which is not covered in this book.\n\n\n\nCh. 15\nApplications.\n\n\nCh. 15\nCh. 16\nInference for one proportion.\n\n\nCh. 16\nCh. 17\nInference for two proportions.\n\n\nCh. 17\n\nChi-square goodness-of-fit test. (This is only covered in IMS in a standalone R tutorial appearing in Ch. 23.)\n\n\nCh. 18\nCh. 18\nChi-square test for independence.\n\n\nCh. 19\nCh. 19\nInference for one mean.\n\n\nCh. 20\nCh. 21\nInference for paired data.\n\n\nCh. 21\nCh. 20\nInference for two independent means.\n\n\nCh. 22\nCh. 22\nANOVA. This is the last chapter of this book.\n\n\n\nCh. 23\nApplications.\n\n\n\nCh. 24\nInference for linear regression with a single predictor.\n\n\n\nCh. 25\nInference for linear regression with multiple predictors.\n\n\n\nCh. 26\nInference for logistic regression.\n\n\n\nCh. 27\nApplications.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Concordance with *Introduction to Modern Statistics* (IMS)</span>"
    ]
  }
]